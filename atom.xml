<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sampwood的One Piece</title>
  
  <subtitle>step by step</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sampwood.github.io/"/>
  <updated>2019-04-01T01:07:24.544Z</updated>
  <id>https://sampwood.github.io/</id>
  
  <author>
    <name>Sampwood</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm scripts设置环境变量方法</title>
    <link href="https://sampwood.github.io/2019/04/01/npm-scripts%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    <id>https://sampwood.github.io/2019/04/01/npm-scripts设置环境变量方法/</id>
    <published>2019-04-01T00:59:06.000Z</published>
    <updated>2019-04-01T01:07:24.544Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>package.json</code> 中，如果希望在 <code>script</code> 属性的运行脚本中设置环境变量，来区分开发环境 或 生产环境。<br>unix与windows环境的设置方式是不同的。<br>这个不同可以通过<code>cross-env</code>来实现跨平台设置。</p><a id="more"></a><p>windows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set NODE_ENV=production</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;set NODE_ENV=production &amp;&amp; npm run build&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;set NODE_ENV=development &amp;&amp; npm run dev&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>linux &amp; mac:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export NODE_ENV=production</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;NODE_ENV=production npm run build&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;NODE_ENV=development npm run dev&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cross-env跨平台设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-env -D</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV=production npm run build&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=development npm run dev&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/mengff/p/7350030.html" target="_blank" rel="noopener">npm scripts设置环境变量方法</a></li><li><a href="https://www.jianshu.com/p/60c4ce9111c0" target="_blank" rel="noopener">package.json里script设置环境变量，unix与windows的区别</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 中，如果希望在 &lt;code&gt;script&lt;/code&gt; 属性的运行脚本中设置环境变量，来区分开发环境 或 生产环境。&lt;br&gt;unix与windows环境的设置方式是不同的。&lt;br&gt;这个不同可以通过&lt;code&gt;cross-env&lt;/code&gt;来实现跨平台设置。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="linux" scheme="https://sampwood.github.io/tags/linux/"/>
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
      <category term="npm" scheme="https://sampwood.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>indexDB的使用</title>
    <link href="https://sampwood.github.io/2019/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8indexDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sampwood.github.io/2019/02/28/浏览器indexDB的使用/</id>
    <published>2019-02-28T06:27:33.000Z</published>
    <updated>2019-03-06T05:51:53.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>现代浏览器提供了一些数据存储方案，例如<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>。</p><p>这些都能在浏览器开发工具的<code>application</code>标签页中能看到。</p><p>在这里记录下，<code>indexedDB</code>的基本用法。</p><blockquote><p>通俗地说，<code>IndexedDB</code> 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。<br><code>IndexedDB</code> 允许储存大量数据，提供查找接口，还能建立索引。<br>这些都是 <code>LocalStorage</code> 所不具备的。<br>就数据库类型而言，<code>IndexedDB</code> 不属于关系型数据库（不支持 <code>SQL</code> 查询语句），更接近 <code>NoSQL</code> 数据库。</p></blockquote><a id="more"></a><blockquote><p>IndexedDB 具有以下特点。<br>（1）<strong>键值对储存</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。<br>（2）<strong>异步</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。<br>（3）<strong>支持事务</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。<br>（4）<strong>同源限制</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。<br>（5）<strong>储存空间大</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。<br>（6）<strong>支持二进制储存</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据库：IDBDatabase 对象</li><li>对象仓库：IDBObjectStore 对象</li><li>索引： IDBIndex 对象</li><li>事务： IDBTransaction 对象</li><li>操作请求：IDBRequest 对象</li><li>指针： IDBCursor 对象</li><li>主键集合：IDBKeyRange 对象</li></ul><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>一个基本的<code>indexDB</code>流程是这样的：</p><ol><li>打开数据库</li><li>在这个数据库中创建对象仓库</li><li>开启事务，并发起数据库操作请求</li><li>监听特定事件，等待操作完成</li><li>对返回结果进行处理</li></ol><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="built_in">window</span>.indexedDB.open(databaseName, version)</span><br><span class="line"></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据库打开报错'</span>)</span><br><span class="line">&#125;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据库打开成功'</span>)</span><br><span class="line">  db = event.target.result</span><br><span class="line">&#125;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据库升级成功'</span>)</span><br><span class="line">  db = event.target.result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>window.indexedDB.open</code>方法接受两个参数，<br>第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。<br>第二个参数是整数，表示数据库的版本。<br>如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。<br>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>onupgradeneeded</code>。</p><p><strong>Note: 数据库升级成功之后会调用<code>onsuccess</code>的回调</strong></p><h4 id="新建对象仓库"><a href="#新建对象仓库" class="headerlink" title="新建对象仓库"></a>新建对象仓库</h4><p>新建/删除/更新对象仓库只能在数据库升级的回调函数中，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This event is only implemented in recent browsers   </span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// Save the IDBDatabase interface </span></span><br><span class="line">  db = event.target.result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an objectStore for this database</span></span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(<span class="string">"name"</span>, &#123; <span class="attr">keyPath</span>: <span class="string">"myKey"</span> &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>主键（key）是默认建立索引的属性。<br>比如，数据记录是<code>{ id: 1, name: &#39;张三&#39; }</code>，那么<code>id</code>属性可以作为主键。<br>主键也可以指定为下一层对象的属性，比如<code>{ foo: { bar: &#39;baz&#39; } }</code>的<code>foo.bar</code>也可以指定为主键。</p><p>如果要指定主键为一个递增的整数，可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createObjectStore(&quot;name&quot;, &#123; keyPath: &quot;myKey&quot;, autoIncrement: true &#125;)</span><br></pre></td></tr></table></figure></p><p>如果要创建索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectStore.createIndex(&apos;name&apos;, &apos;name&apos;, &#123; unique: false &#125;);</span><br><span class="line">objectStore.createIndex(&apos;email&apos;, &apos;email&apos;, &#123; unique: true &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="开启事务，数据库操作"><a href="#开启事务，数据库操作" class="headerlink" title="开启事务，数据库操作"></a>开启事务，数据库操作</h4><p>开启事务的方法是<code>IDBDatabase.transaction([&#39;person&#39;], &#39;readwrite&#39;)</code>。<br>其中<code>person</code>是对象仓库名，第二个参数指明读写权限：<code>&#39;readwrite&#39;/&#39;readonly&#39;</code>。</p><p>开启事务之后通过<code>IDBTransaction.objectStore(name)</code>，拿到 <code>IDBObjectStore</code> 对象。<br>在这个对象上调用增删改查的方法。</p><p><strong>Note: 当一次事务需要对数据库进行多次操作的时候，就要监听事务的回调<code>oncomplete</code>和<code>onerror</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do something when all the data is added to the database.</span></span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"All done!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Don't forget to handle errors!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">"customers"</span>);</span><br><span class="line">customerData.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">customer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = objectStore.add(customer);</span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// event.target.result === customer.ssn;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .add(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">'zhangsan@example.com'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据写入成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据写入失败'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据删除成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove();</span><br></pre></td></tr></table></figure><p><strong>Note: delete方法的参数是主键值</strong></p><h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .put(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">'lisi@example.com'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据更新成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据更新失败'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br></pre></td></tr></table></figure><p><strong>Note: put方法是按照主键值来进行更新。</strong></p><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> transaction = db.transaction([<span class="string">'person'</span>]);</span><br><span class="line">   <span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">'person'</span>);</span><br><span class="line">   <span class="keyword">const</span> request = objectStore.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'查询失败'</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"> event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (request.result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Name: '</span> + request.result.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Age: '</span> + request.result.age);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Email: '</span> + request.result.email);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'未获得数据记录'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br></pre></td></tr></table></figure><p><strong>Note: get方法的参数是主键值</strong></p><h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p><p>在上面，我们对<code>name</code>和<code>email</code>建立了索引。<br>现在，就可以从<code>name</code>找到对应的数据记录了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.transaction([<span class="string">'person'</span>], <span class="string">'readonly'</span>);</span><br><span class="line"><span class="keyword">const</span> store = transaction.objectStore(<span class="string">'person'</span>);</span><br><span class="line"><span class="keyword">const</span> index = store.index(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">const</span> request = index.get(<span class="string">'李四'</span>);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = e.target.result;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note: 因为’name’索引设置成不是唯一的，所以有可能会出现重名。这种情况只会返回一条数据（key最小的数据）。如果想要获取所有的数据，可以使用下面所说的游标</strong></p><h4 id="游标（cursor）的使用"><a href="#游标（cursor）的使用" class="headerlink" title="游标（cursor）的使用"></a>游标（cursor）的使用</h4><p>当需要遍历数据库所有数据的时候，可以使用游标（cursor）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectStore = db.transaction(<span class="string">"customers"</span>).objectStore(<span class="string">"customers"</span>);</span><br><span class="line"></span><br><span class="line">objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    alert(<span class="string">"Name for SSN "</span> + cursor.key + <span class="string">" is "</span> + cursor.value.name);</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"No more entries!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Note: 如果只是想获取到所有的数据，可以使用<code>objectStore.getAll()</code>或<code>objectStore.getAllKeys()</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objectStore.getAll().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Got all customers: "</span> + event.target.result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同样，索引也可以使用游标:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用普通的游标，会获取整个数据对象</span></span><br><span class="line">index.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="comment">// cursor.key is a name, like "Bill", and cursor.value is the whole object.</span></span><br><span class="line">    alert(<span class="string">"Name: "</span> + cursor.key + <span class="string">", SSN: "</span> + cursor.value.ssn + <span class="string">", email: "</span> + cursor.value.email);</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用key游标，会获取数据对象的key</span></span><br><span class="line">index.openKeyCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">    <span class="comment">// cursor.key is a name, like "Bill", and cursor.value is the SSN.</span></span><br><span class="line">    <span class="comment">// No way to directly get the rest of the stored object.</span></span><br><span class="line">    alert(<span class="string">"Name: "</span> + cursor.key + <span class="string">", SSN: "</span> + cursor.primaryKey);</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">浏览器数据库 IndexedDB 入门教程</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener">Using IndexedDB</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;现代浏览器提供了一些数据存储方案，例如&lt;code&gt;cookie&lt;/code&gt;、&lt;code&gt;sessionStorage&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt;和&lt;code&gt;indexedDB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都能在浏览器开发工具的&lt;code&gt;application&lt;/code&gt;标签页中能看到。&lt;/p&gt;
&lt;p&gt;在这里记录下，&lt;code&gt;indexedDB&lt;/code&gt;的基本用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗地说，&lt;code&gt;IndexedDB&lt;/code&gt; 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。&lt;br&gt;&lt;code&gt;IndexedDB&lt;/code&gt; 允许储存大量数据，提供查找接口，还能建立索引。&lt;br&gt;这些都是 &lt;code&gt;LocalStorage&lt;/code&gt; 所不具备的。&lt;br&gt;就数据库类型而言，&lt;code&gt;IndexedDB&lt;/code&gt; 不属于关系型数据库（不支持 &lt;code&gt;SQL&lt;/code&gt; 查询语句），更接近 &lt;code&gt;NoSQL&lt;/code&gt; 数据库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="浏览器" scheme="https://sampwood.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>代码检查工作流之husky+lint-staged</title>
    <link href="https://sampwood.github.io/2019/02/28/husky-lint-staged/"/>
    <id>https://sampwood.github.io/2019/02/28/husky-lint-staged/</id>
    <published>2019-02-28T06:13:09.000Z</published>
    <updated>2019-03-06T05:51:53.737Z</updated>
    
    <content type="html"><![CDATA[<p>虽然大家都会在项目中使用eslint等工具来进行代码格式检查。<br>但如果每次都手动去跑<code>npm run lint</code>是一件很麻烦的事情，而且很容易忘记。</p><p>那么，有没有办法解决这个问题呢？</p><p>在这里我用这个办法：在<code>git commit</code>的时候来自动跑eslint来检查代码。</p><p>需要的工具是： <code>husky</code> + <code>lint-staged</code></p><p><code>husky</code>的作用是提供<code>git commit hook</code>，<code>lint-staged</code>的作用是让eslint的范围限定在本次的改动文件中。</p><a id="more"></a><h3 id="配置husky-lint-staged"><a href="#配置husky-lint-staged" class="headerlink" title="配置husky+lint-staged"></a>配置<code>husky</code>+<code>lint-staged</code></h3><p>安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D husky lint-staged</span><br></pre></td></tr></table></figure></p><p>修改<code>package.json</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;src/**/*.js&quot;: &quot;eslint&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/a/1190000009546913" target="_blank" rel="noopener">用 husky 和 lint-staged 构建超溜的代码检查工作流</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然大家都会在项目中使用eslint等工具来进行代码格式检查。&lt;br&gt;但如果每次都手动去跑&lt;code&gt;npm run lint&lt;/code&gt;是一件很麻烦的事情，而且很容易忘记。&lt;/p&gt;
&lt;p&gt;那么，有没有办法解决这个问题呢？&lt;/p&gt;
&lt;p&gt;在这里我用这个办法：在&lt;code&gt;git commit&lt;/code&gt;的时候来自动跑eslint来检查代码。&lt;/p&gt;
&lt;p&gt;需要的工具是： &lt;code&gt;husky&lt;/code&gt; + &lt;code&gt;lint-staged&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;husky&lt;/code&gt;的作用是提供&lt;code&gt;git commit hook&lt;/code&gt;，&lt;code&gt;lint-staged&lt;/code&gt;的作用是让eslint的范围限定在本次的改动文件中。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linter" scheme="https://sampwood.github.io/categories/coding/linter/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
      <category term="eslint" scheme="https://sampwood.github.io/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>ssh的使用和配置</title>
    <link href="https://sampwood.github.io/2019/02/28/ssh%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://sampwood.github.io/2019/02/28/ssh的使用和配置/</id>
    <published>2019-02-28T05:55:00.000Z</published>
    <updated>2019-03-28T01:17:58.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检查已经存在的ssh-keys"><a href="#检查已经存在的ssh-keys" class="headerlink" title="检查已经存在的ssh keys"></a>检查已经存在的ssh keys</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure><h3 id="新建ssh-key"><a href="#新建ssh-key" class="headerlink" title="新建ssh key"></a>新建ssh key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><h4 id="使用ssh-agent来管理ssh-key"><a href="#使用ssh-agent来管理ssh-key" class="headerlink" title="使用ssh-agent来管理ssh key"></a>使用ssh-agent来管理ssh key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="修改ssh-key的密码"><a href="#修改ssh-key的密码" class="headerlink" title="修改ssh key的密码"></a>修改ssh key的密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f ~/.ssh/id_rsa -p</span><br></pre></td></tr></table></figure><h3 id="配置不同的host使用不同的ssh"><a href="#配置不同的host使用不同的ssh" class="headerlink" title="配置不同的host使用不同的ssh"></a>配置不同的host使用不同的ssh</h3><p>在<code>~/.ssh</code>文件夹下，新建<code>config</code>文件并写入下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Host xxx.com</span><br><span class="line">  HostName 192.168.1.1</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/sampwood_id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/sampwood_id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://help.github.com/en/articles/connecting-to-github-with-ssh" target="_blank" rel="noopener">Connecting to GitHub with SSH</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;检查已经存在的ssh-keys&quot;&gt;&lt;a href=&quot;#检查已经存在的ssh-keys&quot; class=&quot;headerlink&quot; title=&quot;检查已经存在的ssh keys&quot;&gt;&lt;/a&gt;检查已经存在的ssh keys&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ls -al ~/.ssh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;新建ssh-key&quot;&gt;&lt;a href=&quot;#新建ssh-key&quot; class=&quot;headerlink&quot; title=&quot;新建ssh key&quot;&gt;&lt;/a&gt;新建ssh key&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -b 4096 -C &lt;span class=&quot;string&quot;&gt;&quot;your_email@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;使用ssh-agent来管理ssh-key&quot;&gt;&lt;a href=&quot;#使用ssh-agent来管理ssh-key&quot; class=&quot;headerlink&quot; title=&quot;使用ssh-agent来管理ssh key&quot;&gt;&lt;/a&gt;使用ssh-agent来管理ssh key&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;eval&lt;/span&gt; $(ssh-agent -s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-add ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>节流和防抖</title>
    <link href="https://sampwood.github.io/2019/01/11/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"/>
    <id>https://sampwood.github.io/2019/01/11/节流和防抖/</id>
    <published>2019-01-11T06:21:07.000Z</published>
    <updated>2019-03-06T05:51:53.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>函数防抖（debounce）</strong></p><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间</p></blockquote><p><strong>函数节流（throttle）</strong></p><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期</p></blockquote><p><strong>函数节流（throttle）</strong>与 <strong>函数防抖（debounce）</strong>都是为了限制函数的执行频次，<br>以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</p><a id="more"></a><p>常用的场景有：</p><ul><li>window对象的resize、scroll事件</li><li>拖拽时的mousemove事件</li><li>文字输入、自动完成的keyup事件 </li></ul><p><strong>话句话来说这两者的区别就是，是否在动作持续的过程中，重新计算过期时间。</strong></p><p>防抖 只会在动作“真正结束”后才触发函数，节流 会在超过预定时候后就会触发函数</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>函数防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">          clearTimeout(timer);</span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'boom'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(debounce(fn,<span class="number">500</span>),<span class="number">1000</span>) <span class="comment">// 第一次在1500ms后触发，之后每1000ms触发一次</span></span><br><span class="line"></span><br><span class="line">setInterval(debounce(fn,<span class="number">2000</span>),<span class="number">1000</span>) <span class="comment">// 不会触发一次（我把函数防抖看出技能读条，如果读条没完成就用技能，便会失败而且重新读条）</span></span><br></pre></td></tr></table></figure><p>函数节流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, gapTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _lastTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _nowTime = + <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (_nowTime - _lastTime &gt; gapTime || !_lastTime) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      _lastTime = _nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'boom'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(throttle(fn,<span class="number">1000</span>),<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/a/1190000008768202" target="_blank" rel="noopener">函数节流与函数防抖</a></li><li><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">轻松理解JS函数节流和函数防抖</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;函数防抖（debounce）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数节流（throttle）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数节流（throttle）&lt;/strong&gt;与 &lt;strong&gt;函数防抖（debounce）&lt;/strong&gt;都是为了限制函数的执行频次，&lt;br&gt;以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="utils" scheme="https://sampwood.github.io/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题</title>
    <link href="https://sampwood.github.io/2019/01/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://sampwood.github.io/2019/01/08/跨域问题/</id>
    <published>2019-01-08T02:22:54.000Z</published>
    <updated>2019-03-06T05:51:53.743Z</updated>
    
    <content type="html"><![CDATA[<p>跨域在前端是个很常见的场景。<br>首先，我们先来了解下什么是跨域，什么情况下出现跨域。</p><h3 id="概念以及场景"><a href="#概念以及场景" class="headerlink" title="概念以及场景"></a>概念以及场景</h3><p>跨域的始作俑者是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略</a>:</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><p>换句话说就是，浏览器限制了，我们在一个页面下面去调用另外一个源的资源。<br>最常见的场景是我们在当前页面下调用了另一个源的接口。结果浏览器直接报错了，说不行，不能这样干。</p><p>下面是同源的定义：</p><blockquote><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p></blockquote><a id="more"></a><h4 id="造成跨域的两种策略"><a href="#造成跨域的两种策略" class="headerlink" title="造成跨域的两种策略"></a>造成跨域的两种策略</h4><p>浏览器的同源策略会导致跨域，这里同源策略又分为以下两种</p><ol><li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li><li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</li></ol><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p>跨域的问题是有解决方案的。</p><h4 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 对于这个方式，阮一峰老师总结的文章特别好，希望深入了解的可以看一下<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html。" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html。</a></p><h4 id="jsnop"><a href="#jsnop" class="headerlink" title="jsnop"></a>jsnop</h4><p>利用 “在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的” 来实现跨域</p><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><h4 id="document-domain来跨子域"><a href="#document-domain来跨子域" class="headerlink" title="document.domain来跨子域"></a>document.domain来跨子域</h4><p>对于主域名相同，而子域名不同的情况，可以使用document.domain来跨域 这种方式非常适用于iframe跨域的情况。</p><h4 id="window-name进行跨域"><a href="#window-name进行跨域" class="headerlink" title="window.name进行跨域"></a>window.name进行跨域</h4><p>window.name跨域同样是受到同源策略限制，父框架和子框架的src必须指向统一域名。<br>window.name的优势在于，name的值在不同的页面(或者不同的域名)，加载后仍然存在，除非你显示的更改。并且支持的长度达到2M.</p><h4 id="location-hash跨域"><a href="#location-hash跨域" class="headerlink" title="location.hash跨域"></a>location.hash跨域</h4><p>location.hash方式跨域，是子框架具有修改父框架src的hash值，通过这个属性进行传递数据，且更改hash值，页面不会刷新。<br>但是传递的数据的字节数是有限的。</p><blockquote><p>补充： 其实还有一些方法，比如window.name和location.hash。<br>就很适用于iframe的跨域，不过iframe用的比较少了，所以这些方法也就有点过时了。</p></blockquote><h4 id="使用postMessage实现页面之间通信"><a href="#使用postMessage实现页面之间通信" class="headerlink" title="使用postMessage实现页面之间通信"></a>使用postMessage实现页面之间通信</h4><p>window.postMessage是一个HTML5的api，允许两个窗口之间进行跨域发送消息。<br>这个应该就是以后解决dom跨域通用方法了，具体可以参照MDN。</p><h3 id="一些实用方法"><a href="#一些实用方法" class="headerlink" title="一些实用方法"></a>一些实用方法</h3><ul><li>跨域下获取iframe的父页面URL：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getParentHost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> host = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent !== <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      host = parent.location.origin;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="built_in">document</span>.referrer;</span><br><span class="line">      host = url.split(<span class="string">'/'</span>).splice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/28562290" target="_blank" rel="noopener">跨域的那些事儿</a></li><li><a href="https://www.jianshu.com/p/06529543f03a" target="_blank" rel="noopener">前端跨域整理</a></li><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">不要再问我跨域的问题了</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域在前端是个很常见的场景。&lt;br&gt;首先，我们先来了解下什么是跨域，什么情况下出现跨域。&lt;/p&gt;
&lt;h3 id=&quot;概念以及场景&quot;&gt;&lt;a href=&quot;#概念以及场景&quot; class=&quot;headerlink&quot; title=&quot;概念以及场景&quot;&gt;&lt;/a&gt;概念以及场景&lt;/h3&gt;&lt;p&gt;跨域的始作俑者是&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同源策略&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说就是，浏览器限制了，我们在一个页面下面去调用另外一个源的资源。&lt;br&gt;最常见的场景是我们在当前页面下调用了另一个源的接口。结果浏览器直接报错了，说不行，不能这样干。&lt;/p&gt;
&lt;p&gt;下面是同源的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="http" scheme="https://sampwood.github.io/categories/coding/http/"/>
    
    
      <category term="跨域" scheme="https://sampwood.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>git多平台换行符问题(LF/CRLF)</title>
    <link href="https://sampwood.github.io/2019/01/07/git%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98-LF-CRLF/"/>
    <id>https://sampwood.github.io/2019/01/07/git多平台换行符问题-LF-CRLF/</id>
    <published>2019-01-07T08:51:29.000Z</published>
    <updated>2019-03-06T05:51:53.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>目前大部分的前端开发用macos/windows来开发，linux系统使用的较少。<br>一个多人开发的项目必然会覆盖windows和unix系统。<br>而这个两个系统间存在一些差异，其中之一就是文本换行的方式。</p><p>CRLF, LF 都是用来表示文本换行的方式。主流的操作系统一般使用CRLF或者LF作为其文本的换行符。<br>CR(Carriage Return) 代表回车，对应字符 <code>\r</code>；LF(Line Feed) 代表换行，对应字符 <code>\n</code>。</p><p>unix/linux(macos)使用的是LF，windows使用的是CRLF。</p><p>跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。<br>最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们 <code>diff</code> 不能正确反映本次的修改。</p><p>例如在查看<code>diff</code>的时候，出现下面的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">warning: LF will be replaced by CRLF in .gitignore.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in README.md.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="git处理"><a href="#git处理" class="headerlink" title="git处理"></a>git处理</h3><p>还好 Git 在设计时就考虑了这一点，提供了换行符相关的处理方式。</p><p>这里先指定两个非官方的概念，方便后面解释与描述：(重要，否则后面看不懂)</p><ol><li><strong>标准化</strong> 指在提交代码到git数据库(本地库) 中将文本文件中的换行符CRLF转为LF的过程</li><li><strong>转换</strong> 指在检出Git数据库代码过程中将文本文件中的换行符LF转换为CRLF的过程</li></ol><h4 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a>core.autocrlf</h4><p>git提供了一个 <code>autocrlf</code> 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：</p><ul><li>true: 提交时转换为 LF，检出时转换为 CRLF</li><li>false: 提交检出均不转换</li><li>input: 提交时转换为LF，检出时不转换</li></ul><blockquote><p>CRLF 与 LF 混合的文本文件不受此配置控制。</p></blockquote><blockquote><p>Git 安装后默认为 false</p></blockquote><p>所以，一种规范换行符的方式是这样的：</p><p>使用 Windows 系统的开发者设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.aurocrlf true</span><br></pre></td></tr></table></figure></p><p>使用 Linux/MacOS 的开发者设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure></p><h4 id="core-safecrlf"><a href="#core-safecrlf" class="headerlink" title="core.safecrlf"></a>core.safecrlf</h4><p>git同时提供了另一个配置项 <code>safecrlf</code>，用于检查文件是否包含混合换行符，该配置也有三个可选项：</p><ul><li>true 禁止提交混合换行符的文本文件(git add 的时候会被拦截，提示异常)</li><li>warn 提交混合换行符的文本文件的时候发出警告，但是不会阻止 git add 操作</li><li>false 不禁止提交混合换行符的文本文件（默认配置）</li></ul><p>该配置用来防止错误的标准化与转换。</p><h4 id="gitattributes-文件"><a href="#gitattributes-文件" class="headerlink" title=".gitattributes 文件"></a><code>.gitattributes</code> 文件</h4><p><code>core.autocrlf</code> 的配置依赖于每一位参与项目的开发机器上的配置，这很难确保每个人都能正确配置。<br>于是在规范项目中的换行符方面，还有一套添加配置文件的方案。<br>在项目的根目录下可以添加一个<code>.gitattributes</code> 文件。<br>它的优先级高于<code>core.autocrlf</code>的设置，可以覆盖<code>core.autocrlf</code>的。<br>它类似于 <code>.gitignore</code> 文件，随提交修改生效，一个项目中可以维持一份相同的配置。<br>所以，它能够避免每个开发人员配置不同的问题。</p><p><code>.gitattributes</code>文件的功能不只有配置换行符，所以它的配置相对复杂一下。<br>详细的说明文档可以参考 <a href="http://schacon.github.io/git/gitattributes.html" target="_blank" rel="noopener">地址</a>。<br>这里只针对换行符的配置做一下简单的介绍：</p><p>每行基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter attr1 attr2 ....</span><br></pre></td></tr></table></figure><p>filter 代表匹配文件的通配符，在它后面跟着相应的属性，用空格间隔。</p><p>filter 的选项比较简单，常见的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 匹配所有文件</span><br><span class="line">*.txt  匹配文件名以txt结尾的文件</span><br></pre></td></tr></table></figure><p>attr的选择比较多，其中与换行符相关的属性只有几条：</p><ul><li>text<ul><li>text 自动完成标准化与转换</li><li>-text 不执行标准化与转换</li><li>text=auto 根据 Git 决定是否需要执行标准化与转化</li><li>不设置 使用core.autocrlf配置决定是否执行标准化与转换</li></ul></li><li>eol<ul><li>eol=lf 强制完成标准化，不执行转换（相当于指定转换为LF格式）</li><li>eol=crlf 强制完成标准化，指定转换为CRLF格式</li></ul></li><li>binary<ul><li>binary 二进制文件不参与标准化与转换</li><li>不设置 由 Git 决定是否为二进制文件</li></ul></li></ul><blockquote><p>text 设置的时候，转换自动转换到对应平台的换行符</p></blockquote><blockquote><p>行号高的设置会覆盖行号低的设置</p></blockquote><p>这里给出一个简单的例子来说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Set the default behavior, in case people don&apos;t have core.autocrlf set.</span><br><span class="line">* text eol=lf</span><br><span class="line"></span><br><span class="line"># Denote all files that are truly binary and should not be modified.</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br></pre></td></tr></table></figure></p><p><strong>推荐使用.gitattributes来规范项目中换行符。简单，方便，灵活。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/ec9564fe1c2b" target="_blank" rel="noopener">理解 CRLF，LF</a></li><li><a href="http://blog.konghy.cn/2017/03/19/git-lf-or-crlf/" target="_blank" rel="noopener">Git 多平台换行符问题(LF or CRLF)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;差异&quot;&gt;&lt;a href=&quot;#差异&quot; class=&quot;headerlink&quot; title=&quot;差异&quot;&gt;&lt;/a&gt;差异&lt;/h3&gt;&lt;p&gt;目前大部分的前端开发用macos/windows来开发，linux系统使用的较少。&lt;br&gt;一个多人开发的项目必然会覆盖windows和unix系统。&lt;br&gt;而这个两个系统间存在一些差异，其中之一就是文本换行的方式。&lt;/p&gt;
&lt;p&gt;CRLF, LF 都是用来表示文本换行的方式。主流的操作系统一般使用CRLF或者LF作为其文本的换行符。&lt;br&gt;CR(Carriage Return) 代表回车，对应字符 &lt;code&gt;\r&lt;/code&gt;；LF(Line Feed) 代表换行，对应字符 &lt;code&gt;\n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;unix/linux(macos)使用的是LF，windows使用的是CRLF。&lt;/p&gt;
&lt;p&gt;跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。&lt;br&gt;最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们 &lt;code&gt;diff&lt;/code&gt; 不能正确反映本次的修改。&lt;/p&gt;
&lt;p&gt;例如在查看&lt;code&gt;diff&lt;/code&gt;的时候，出现下面的情况：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;warning: LF will be replaced by CRLF in .gitignore.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The file will have its original line endings in your working directory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;warning: LF will be replaced by CRLF in README.md.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The file will have its original line endings in your working directory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="version-control" scheme="https://sampwood.github.io/categories/coding/version-control/"/>
    
    
      <category term="git" scheme="https://sampwood.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>全局配置ESLint</title>
    <link href="https://sampwood.github.io/2019/01/04/%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AEESLint/"/>
    <id>https://sampwood.github.io/2019/01/04/全局配置ESLint/</id>
    <published>2019-01-04T06:23:58.000Z</published>
    <updated>2019-03-06T05:51:53.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ESLint是一个Javascript静态检查工具，它可以帮你养成良好的编程习惯，使你的javascript代码达到国际化的水准。ESLint是所有Javascrpt静态检查工具里最晚诞生的一个，之前还曾经有过JSLint以及JSHint等工具，但JSLint和JSHint都是用的一套标准，在目前这个前端技术飞速发展的时代已经显得有点落伍。ESLint的好处是既提供了国际大厂的标准，同时又给了你自定义标准的可能性。ESLint的推荐设置方式是按项目设置，但是如果我们有很多个不同的javascript项目的话，一个一个去设置未免太麻烦，所以在这里介绍的是全局设置方法，一次设置，所有项目全部采用同一标准。</p></blockquote><p>目前在自己的机子上面用到的eslint配置是：<code>airbnb</code>+<code>eslint-plugin-vue</code>。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要安装的包有：<code>eslint</code>, <code>eslint-config-airbnb-base</code>, <code>eslint-plugin-import</code>, <code>eslint-plugin-vue</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue</span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>安装好依赖包之后，需要编写全局<code>.eslintrc</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;airbnb-base&quot;,</span><br><span class="line">    &quot;plugin:vue/recommended&quot;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此这般，就可以在任何地方js文件中使用同一套标准去检查了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651230875&amp;idx=1&amp;sn=092211db96adfc85a26b457f7e9421a0&amp;chksm=bd494b1f8a3ec20902ad0df7d6a3735b536fe585086abc9035fe24d69549bb4c81cf88658515&amp;mpshare=1&amp;scene=1&amp;srcid=0104C1J16lllbEgkIyFIFJmp#rd" target="_blank" rel="noopener">【第1495期】 ESLint 工作原理探讨</a></li><li><a href="https://segmentfault.com/a/1190000005984309" target="_blank" rel="noopener">atom使用全局配置ESLint</a></li><li><a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb" target="_blank" rel="noopener">airbnb/javascript</a></li><li><a href="https://vuejs.github.io/eslint-plugin-vue/user-guide/" target="_blank" rel="noopener">eslint-plugin-vue</a></li><li><a href="https://github.com/dustinspecker/awesome-eslint" target="_blank" rel="noopener">dustinspecker/awesome-eslint</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ESLint是一个Javascript静态检查工具，它可以帮你养成良好的编程习惯，使你的javascript代码达到国际化的水准。ESLint是所有Javascrpt静态检查工具里最晚诞生的一个，之前还曾经有过JSLint以及JSHint等工具，但JSLint和JSHint都是用的一套标准，在目前这个前端技术飞速发展的时代已经显得有点落伍。ESLint的好处是既提供了国际大厂的标准，同时又给了你自定义标准的可能性。ESLint的推荐设置方式是按项目设置，但是如果我们有很多个不同的javascript项目的话，一个一个去设置未免太麻烦，所以在这里介绍的是全局设置方法，一次设置，所有项目全部采用同一标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前在自己的机子上面用到的eslint配置是：&lt;code&gt;airbnb&lt;/code&gt;+&lt;code&gt;eslint-plugin-vue&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linter" scheme="https://sampwood.github.io/categories/coding/linter/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
      <category term="eslint" scheme="https://sampwood.github.io/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>wsl初体验</title>
    <link href="https://sampwood.github.io/2018/12/29/wsl%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://sampwood.github.io/2018/12/29/wsl初体验/</id>
    <published>2018-12-29T08:04:52.000Z</published>
    <updated>2019-03-06T05:51:53.742Z</updated>
    
    <content type="html"><![CDATA[<p>wsl, 就是Windows Subsystem for Linux, 简单的说 WSL 就是让开发者在 Windows 上无需虚拟机就可以搭建一套 Linux 开发环境。</p><p>使用 WSL 的好处是：</p><ol><li>最主要的一点，你可以快速的开启 Linux 环境，之前我的做法是开启虚拟器，占用资源多而且打开慢。</li><li>通过 window商店 选择多种 Linux 发行版，目前支持 Ubuntu(16.04 LTS)、openSUSE Leap 42、 SUSE Linux Enterprise Server。</li><li>使用 Linux 命令行工具处理一些问题，例如 sed, awk 等。</li><li>使用 Linux 内置包管理器安装一些软件，例如 git redis 等，基本上一条命令就能安装好。</li></ol><a id="more"></a><h3 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h3><ol><li><p>控制面板 -&gt; 程序 -&gt; 启用或关闭 Windows 功能 -&gt; 勾选 适用Linux的Windows子系统 （我是秋季创造者更新版本，我记得之前低版本可能是 beta 版本）</p><p><img src="..\images\wsl.jpg" alt="\images\wsl"></p></li><li><p>打开 window商店，选择合适的 Linux 发行版安装 (这里搜索Linux 根据下面第一个suggestion 进入)，这里我选择了 Ubuntu</p></li><li><p>重启电脑。打开 Ubuntu ，第一次需要等待一会，设置账号密码</p></li></ol><p>如此，wsl就安装好了，可以使用ubuntu的命令行啦~~</p><h3 id="配置命令行"><a href="#配置命令行" class="headerlink" title="配置命令行"></a>配置命令行</h3><p>既然可以使用ubuntu的bash，我们就可以配置bash，来让我们的操作更舒适。</p><p>例如安装zsh+Oh My ZSH，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh -y</span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>让命令行高亮的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p><p>激活这个插<code>~/.zshrc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>为了让某些theme能在windows下正常显示，还要安装<code>Powerline</code>字体，例如我就安装了<code>DejaVu Sans Mono for Powerline</code> 字体。<br>安装字体之后，就可以在命令行窗口设置字体了，设置之后显示就正常了。</p><p>安装<code>Powerline</code>字体，参考：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p><h4 id="zsh配置文件-zshrc"><a href="#zsh配置文件-zshrc" class="headerlink" title="zsh配置文件.zshrc"></a>zsh配置文件<code>.zshrc</code></h4><p>目前使用的主题是<code>amuse</code>，也自定义了一些命令:</p><ul><li>gcb: git_get_branch 查看当前分支名</li><li>gpg: git_push_gerrit 把当前分支的内容推送到gerrit的相同分支上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"># If you come from bash you might have to change your $PATH.</span><br><span class="line"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span><br><span class="line"></span><br><span class="line"># Path to your oh-my-zsh installation.</span><br><span class="line">  export ZSH=&quot;/home/sam/.oh-my-zsh&quot;</span><br><span class="line"></span><br><span class="line"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span><br><span class="line"># load a random theme each time oh-my-zsh is loaded, in which case,</span><br><span class="line"># to know which specific one was loaded, run: echo $RANDOM_THEME</span><br><span class="line"># See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span><br><span class="line">ZSH_THEME=&quot;amuse&quot;</span><br><span class="line"></span><br><span class="line"># Set list of themes to pick from when loading at random</span><br><span class="line"># Setting this variable when ZSH_THEME=random will cause zsh to load</span><br><span class="line"># a theme from this variable instead of looking in ~/.oh-my-zsh/themes/</span><br><span class="line"># If set to an empty array, this variable will have no effect.</span><br><span class="line"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use case-sensitive completion.</span><br><span class="line"># CASE_SENSITIVE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to use hyphen-insensitive completion.</span><br><span class="line"># Case-sensitive completion must be off. _ and - will be interchangeable.</span><br><span class="line"># HYPHEN_INSENSITIVE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable bi-weekly auto-update checks.</span><br><span class="line"># DISABLE_AUTO_UPDATE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to change how often to auto-update (in days).</span><br><span class="line"># export UPDATE_ZSH_DAYS=13</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable colors in ls.</span><br><span class="line"># DISABLE_LS_COLORS=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to disable auto-setting terminal title.</span><br><span class="line"># DISABLE_AUTO_TITLE=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to enable command auto-correction.</span><br><span class="line"># ENABLE_CORRECTION=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line to display red dots whilst waiting for completion.</span><br><span class="line"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line if you want to disable marking untracked files</span><br><span class="line"># under VCS as dirty. This makes repository status check for large repositories</span><br><span class="line"># much, much faster.</span><br><span class="line"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment the following line if you want to change the command execution time</span><br><span class="line"># stamp shown in the history command output.</span><br><span class="line"># You can set one of the optional three formats:</span><br><span class="line"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span><br><span class="line"># or set a custom format using the strftime function format specifications,</span><br><span class="line"># see &apos;man strftime&apos; for details.</span><br><span class="line"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span><br><span class="line"></span><br><span class="line"># Would you like to use another custom folder than $ZSH/custom?</span><br><span class="line"># ZSH_CUSTOM=/path/to/new-custom-folder</span><br><span class="line"></span><br><span class="line"># Which plugins would you like to load?</span><br><span class="line"># Standard plugins can be found in ~/.oh-my-zsh/plugins/*</span><br><span class="line"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span><br><span class="line"># Example format: plugins=(rails git textmate ruby lighthouse)</span><br><span class="line"># Add wisely, as too many plugins slow down shell startup.</span><br><span class="line">plugins=(</span><br><span class="line">  git,</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"># User configuration</span><br><span class="line"></span><br><span class="line"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span><br><span class="line"></span><br><span class="line"># You may need to manually set your language environment</span><br><span class="line"># export LANG=en_US.UTF-8</span><br><span class="line"></span><br><span class="line"># Preferred editor for local and remote sessions</span><br><span class="line"> if [[ -n $SSH_CONNECTION ]]; then</span><br><span class="line">   export EDITOR=&apos;vim&apos;</span><br><span class="line"> else</span><br><span class="line">   export EDITOR=&apos;mvim&apos;</span><br><span class="line"> fi</span><br><span class="line"></span><br><span class="line"># Compilation flags</span><br><span class="line"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span><br><span class="line"></span><br><span class="line"># ssh</span><br><span class="line"># export SSH_KEY_PATH=&quot;~/.ssh/rsa_id&quot;</span><br><span class="line"></span><br><span class="line"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span><br><span class="line"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span><br><span class="line"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span><br><span class="line"># For a full list of active aliases, run `alias`.</span><br><span class="line">#</span><br><span class="line"># Example aliases</span><br><span class="line"># alias zshconfig=&quot;mate ~/.zshrc&quot;</span><br><span class="line"># alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span><br><span class="line">alias cdcode=&quot;cd /mnt/d/code&quot;</span><br><span class="line"></span><br><span class="line">function git_get_branch &#123;</span><br><span class="line">  br=`git branch | grep &quot;*&quot;`</span><br><span class="line">  echo $&#123;br/* /&#125;</span><br><span class="line">&#125;</span><br><span class="line">alias gcb=&quot;git_get_branch&quot;</span><br><span class="line">function git_push_gerrit &#123;</span><br><span class="line">  GIT_CURRENT_BRANCH=`git_get_branch`</span><br><span class="line">  echo Current branch is $GIT_CURRENT_BRANCH</span><br><span class="line">  `git push origin HEAD:refs/for/$GIT_CURRENT_BRANCH`</span><br><span class="line">&#125;</span><br><span class="line">alias gpg=&quot;git_push_gerrit&quot;</span><br></pre></td></tr></table></figure><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ol><li>sublime整合eslint时，如果是用wsl来安装npm依赖，node_modules文件夹下的.bin文件夹不会出现*.cmd文件，这就会影响eslint的运行</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/javanoob/p/wsl.html" target="_blank" rel="noopener">三流程序员的自我修养</a></li><li><a href="https://www.jianshu.com/p/b147735ff3f2" target="_blank" rel="noopener">调教你的WSL终端</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wsl, 就是Windows Subsystem for Linux, 简单的说 WSL 就是让开发者在 Windows 上无需虚拟机就可以搭建一套 Linux 开发环境。&lt;/p&gt;
&lt;p&gt;使用 WSL 的好处是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最主要的一点，你可以快速的开启 Linux 环境，之前我的做法是开启虚拟器，占用资源多而且打开慢。&lt;/li&gt;
&lt;li&gt;通过 window商店 选择多种 Linux 发行版，目前支持 Ubuntu(16.04 LTS)、openSUSE Leap 42、 SUSE Linux Enterprise Server。&lt;/li&gt;
&lt;li&gt;使用 Linux 命令行工具处理一些问题，例如 sed, awk 等。&lt;/li&gt;
&lt;li&gt;使用 Linux 内置包管理器安装一些软件，例如 git redis 等，基本上一条命令就能安装好。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linux" scheme="https://sampwood.github.io/categories/coding/linux/"/>
    
    
      <category term="linux" scheme="https://sampwood.github.io/tags/linux/"/>
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>gitlab-ci基础配置</title>
    <link href="https://sampwood.github.io/2018/10/31/gitlab-ci%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>https://sampwood.github.io/2018/10/31/gitlab-ci基础配置/</id>
    <published>2018-10-31T12:54:34.000Z</published>
    <updated>2019-03-06T06:48:15.664Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一个“在vps上搭建一个git仓库并实现代码提交之后自动部署到nginx上”，<br>但是这个需要自己去维护<code>git hook</code>钩子触发的脚本，而且每次push之后都只能在本地的terminal中看到脚本的执行情况。<br>其实我们可以使用<code>gitlab-ci</code>来完成我们需要的东西。<br><a id="more"></a></p><h3 id="使用gitlab"><a href="#使用gitlab" class="headerlink" title="使用gitlab"></a>使用gitlab</h3><p>使用<code>gitlab-ci</code>来完成自动部署的第一步当然是使用gitlab。<br>当然可以自己搭建gitlab仓库，不过我用了官方 <a href="https://gitlab.com" target="_blank" rel="noopener">gitlab</a></p><h4 id="创建自己的项目"><a href="#创建自己的项目" class="headerlink" title="创建自己的项目"></a>创建自己的项目</h4><p>页面上点击<code>New project</code>，然后输入项目名称就ok了。</p><h4 id="配置-gitlab-ci-yml文件"><a href="#配置-gitlab-ci-yml文件" class="headerlink" title="配置.gitlab-ci.yml文件"></a>配置<code>.gitlab-ci.yml</code>文件</h4><p>要使用<code>gitlab-ci</code>，需要在项目中配置<code>.gitlab-ci.yml</code>文件。</p><p>关于这个文件的编写规则可以参考：<a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">Configuration of your jobs with .gitlab-ci.yml</a></p><p>简述下我的理解：</p><ul><li>全局关键字：<ul><li>image：指定特定的运行版本；例如<code>image: node:latest</code></li><li>stages：定义将被使用的运行阶段；一般分为三段：<code>build</code>, <code>test</code>, <code>deploy</code>；如果未定义那这三个都相当于存在；阶段的顺序是从<code>build</code>到<code>test</code>到<code>deploy</code>；相同阶段的<code>job</code>会并行执行；前一阶段错误将直接把<code>commit</code>标记为<code>failed</code>并且中断后续<code>job</code>的执行；</li><li>cache： 指明在所有<code>job</code>之间的默认的共享文件、文件夹;如果<code>job</code>配置了<code>cache</code>，则会使用配置的<code>cache</code>，忽略全局的<code>cache</code></li></ul></li><li><code>job</code>内部关键字<ul><li>stage：定义当前<code>job</code>所在的阶段；值从全局<code>stages</code>里面取一个</li><li>script：定义要执行的脚本；可以多个，每个另起一行用<code>-</code>开头；（每个<code>job</code>都必须存在<code>script</code>）</li><li>tags：用来知名特定的<code>Runner</code>来跑当前<code>job</code>（很关键，弄很久才知道这个是最重要的，不然pipelines会一直处于pending状态，因为没有特定的runner来执行这个job）</li><li>only：分支名（指明那个分支会跑当前<code>job</code>）</li><li>except：分支名（指明那个分支<strong>不</strong>跑当前<code>job</code>）</li><li>cache：指明在不同<code>job</code>之间的共享文件、文件夹;<ul><li>paths：目录；可以多个，每个另起一行用<code>-</code>开头；</li><li>key：如果你在不同的<code>job</code>共享了不同的目录，那么你就需要key来防止cache被覆盖</li><li>untracked：设置是否缓存未添加到git管理的文件</li><li>policy：默认的<code>policy</code>是<code>pull-push</code>的，也就是在<code>job</code>执行前下拉缓存，结束后保存缓存；可以设置成<code>pull</code>，既只读取缓存</li></ul></li><li>artifacts：指明在<code>job</code>成功完成之后可以在gitlab上面下载到的文件（意思就是：指定的文件会被上传到gitlab，然后可以在<br>当前<code>Pipeline</code>中下载这些文件）<ul><li>paths：指定上传的目录；可以多个，每个另起一行用</li></ul></li><li>dependencies：应该和<code>artifacts</code>一起使用，来在不同的<code>job</code>间共享<code>artifacts</code>文件。（原理是，某个<code>job</code>配置了<code>artifacts</code>之后，<code>job</code>如果执行成功，就会把对应的文件上传到gitlab；同时，配置了<code>dependencies</code>的<code>job</code>会在脚本执行前去gitlab下载对应的<code>job</code>的<code>artifacts</code>文件）；当然，依赖只能按照<code>stages</code>运行阶段来依赖前一个阶段的<code>job</code></li></ul></li></ul><p>这里贴一个简单的demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">image: node:latest</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  paths:</span><br><span class="line">    - node_modules</span><br><span class="line"></span><br><span class="line">prepare:</span><br><span class="line">  stage: build</span><br><span class="line">  tags:</span><br><span class="line">    - build</span><br><span class="line">  script:</span><br><span class="line">    - npm install</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line"></span><br><span class="line">testCache:</span><br><span class="line">  stage: test</span><br><span class="line">  tags:</span><br><span class="line">    - build</span><br><span class="line">  script:</span><br><span class="line">    - cd node_modules</span><br><span class="line">    - pwd</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  stage: deploy</span><br><span class="line">  tags:</span><br><span class="line">    - build</span><br><span class="line">  script:</span><br><span class="line">    - npm run build</span><br><span class="line">    - mkdir .public</span><br><span class="line">    - cp -r dist/* .public</span><br><span class="line">    - mv .public public</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - public</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br></pre></td></tr></table></figure></p><p>到这，gitlab上的配置就基本OK了。</p><p>接下来，我们需要去服务器上安装<code>gitlab-runner</code>来运行我们定义的<code>job</code>了。</p><h3 id="使用gitlab-runner"><a href="#使用gitlab-runner" class="headerlink" title="使用gitlab-runner"></a>使用gitlab-runner</h3><p>其实具体的安装和使用说明，在gitlab上有很详细的文档。</p><p>在项目首页，点击左侧<code>setting</code>里面的二级菜单<code>CI / CD</code>。找到<code>Runners</code>，点击右边的<code>Expand</code>按钮。<br>找到下面<code>Set up a specific Runner manually</code>的文档。</p><p><img src="/images/gitlab-ci.png" alt="gitlab-ci"></p><p><strong>Note</strong>：也可以直接看下面的内容。</p><h4 id="安装gitlab-runner"><a href="#安装gitlab-runner" class="headerlink" title="安装gitlab-runner"></a>安装gitlab-runner</h4><p>这里是在linux上安装gitlab-runner。</p><ol><li><p>下载合适的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Linux x86-64</span><br><span class="line"> sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"> # Linux x86</span><br><span class="line"> sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386</span><br><span class="line"></span><br><span class="line"> # Linux arm</span><br><span class="line"> sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm</span><br></pre></td></tr></table></figure></li><li><p>修改执行权限： <code>sudo chmod +x /usr/local/bin/gitlab-runner</code></p></li><li>创建Gitlab CI用户：<code>sudo useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell /bin/bash</code></li><li><p>安装和运行服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br></pre></td></tr></table></figure></li><li><p>注册Runner： <code>sudo gitlab-runner register</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://gitlab.com</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx (PS: 就是在【Set up a specific Runner manually】的文档中的registration token)</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">[hostame] my-runner</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class="line">my-tag,another-tag (PS: 这个是最关键的，这个tag和job中的tags要对应才能起作用！！！当然你可以在gitlab中指定它不去匹配)</span><br><span class="line"></span><br><span class="line">...successful</span><br></pre></td></tr></table></figure></li></ol><p><strong>Note</strong>: 还是一句话，注册Runner时输入的tag要和<code>.gitlab-ci.yml</code>文件中<code>job</code>的<code>tags</code>对应起来。</p><p>到这里，gitlab-ci就可以使用了。提交一次试试~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一个“在vps上搭建一个git仓库并实现代码提交之后自动部署到nginx上”，&lt;br&gt;但是这个需要自己去维护&lt;code&gt;git hook&lt;/code&gt;钩子触发的脚本，而且每次push之后都只能在本地的terminal中看到脚本的执行情况。&lt;br&gt;其实我们可以使用&lt;code&gt;gitlab-ci&lt;/code&gt;来完成我们需要的东西。&lt;br&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linux" scheme="https://sampwood.github.io/categories/coding/linux/"/>
    
    
      <category term="linux" scheme="https://sampwood.github.io/tags/linux/"/>
    
      <category term="git" scheme="https://sampwood.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>sublime使用</title>
    <link href="https://sampwood.github.io/2018/10/26/sublime%E4%BD%BF%E7%94%A8/"/>
    <id>https://sampwood.github.io/2018/10/26/sublime使用/</id>
    <published>2018-10-26T09:23:43.000Z</published>
    <updated>2019-03-06T05:51:53.738Z</updated>
    
    <content type="html"><![CDATA[<p>因为喜欢sublime的配色，所以一直都使用sublime来开发前端代码。<br>下面记录一些常用的配置。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网下载： <a href="http://www.sublimetext.com/" target="_blank" rel="noopener">http://www.sublimetext.com/</a></p><p>然后就是安装<code>package control</code>: <a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a></p><a id="more"></a><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>A File Icon</li><li>AutoFileName</li><li>BracketHighlighter</li><li>DocBlockr</li><li>Emmet</li><li>Git</li><li>GitGutter</li><li>JS Snippets</li><li>JsFormat</li><li>LESS</li><li>MarkdownPreview</li><li>ProjectManager</li><li>SideBarEnhancements</li><li>SublimeCodeIntel</li><li>SublimeLinter</li><li>SublimeLinter-eslint</li><li>SublimeServer</li><li>Termial</li><li>Vue Svntax Highlight</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  // 切换Project</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;keys&quot;: [&quot;ctrl+alt+p&quot;],</span><br><span class="line">      &quot;command&quot;: &quot;prompt_select_workspace&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 快速到行首行尾</span><br><span class="line">  &#123; &quot;keys&quot;: [&quot;ctrl+left&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;bol&quot;, &quot;extend&quot;: false&#125; &#125;,</span><br><span class="line">  &#123; &quot;keys&quot;: [&quot;ctrl+right&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;eol&quot;, &quot;extend&quot;: false&#125; &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;font_size&quot;: 11,</span><br><span class="line">  &quot;ignored_packages&quot;:</span><br><span class="line">  [</span><br><span class="line">      &quot;Vintage&quot;</span><br><span class="line">  ],</span><br><span class="line">  // 竖线</span><br><span class="line">  &quot;rulers&quot;:</span><br><span class="line">  [</span><br><span class="line">      100,</span><br><span class="line">      120</span><br><span class="line">  ],</span><br><span class="line">  &quot;tab_size&quot;: 2,</span><br><span class="line">  &quot;translate_tabs_to_spaces&quot;: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SublimeLinter配置"><a href="#SublimeLinter配置" class="headerlink" title="SublimeLinter配置"></a>SublimeLinter配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SublimeLinter Settings - User</span><br><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;delay&quot;: 0.25,</span><br><span class="line">  &quot;gutter_theme&quot;: &quot;Danish Royalty&quot;,</span><br><span class="line">  &quot;lint_mode&quot;: &quot;background&quot;,</span><br><span class="line">  &quot;linters&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &#123;</span><br><span class="line">      &quot;selector&quot;: &quot;text.html.vue, source.js - meta.attribute-with-value&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;no_column_highlights_line&quot;: false,</span><br><span class="line">  &quot;paths&quot;: &#123;</span><br><span class="line">    &quot;linux&quot;: [],</span><br><span class="line">    &quot;osx&quot;: [],</span><br><span class="line">    &quot;windows&quot;: [&quot;C:/Users/sampwood/AppData/Roaming/npm/eslint&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;show_marks_in_minimap&quot;: true,</span><br><span class="line">  &quot;styles&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mark_style&quot;: &quot;outline&quot;,</span><br><span class="line">      &quot;priority&quot;: 1,</span><br><span class="line">      &quot;scope&quot;: &quot;region.yellowish markup.changed.sublime_linter markup.warning.sublime_linter&quot;,</span><br><span class="line">      &quot;icon&quot;: &quot;dot&quot;,</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">          &quot;warning&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mark_style&quot;: &quot;outline&quot;,</span><br><span class="line">      &quot;priority&quot;: 1,</span><br><span class="line">      &quot;scope&quot;: &quot;region.redish markup.deleted.sublime_linter markup.error.sublime_linter&quot;,</span><br><span class="line">      &quot;icon&quot;: &quot;dot&quot;,</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">          &quot;error&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;syntax_map&quot;: &#123;</span><br><span class="line">    &quot;html (django)&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;html (rails)&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;html 5&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;javascript (babel)&quot;: &quot;javascript&quot;,</span><br><span class="line">    &quot;magicpython&quot;: &quot;python&quot;,</span><br><span class="line">    &quot;php&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;python django&quot;: &quot;python&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;statusbar_branch&quot;: false,</span><br><span class="line">  &quot;statusbar_status&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="projectManager配置"><a href="#projectManager配置" class="headerlink" title="projectManager配置"></a>projectManager配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;projects_path&quot;: [&quot;D:/sublime-folder&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="terminal配置"><a href="#terminal配置" class="headerlink" title="terminal配置"></a>terminal配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // window下终端路径</span><br><span class="line">  &quot;terminal&quot;: &quot;D:\\Program Files\\cmder_mini\\Cmder.exe&quot;,</span><br><span class="line">  //  window下终端参数</span><br><span class="line">  &quot;parameters&quot;: [&quot;/START&quot;, &quot;%CWD%&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为喜欢sublime的配色，所以一直都使用sublime来开发前端代码。&lt;br&gt;下面记录一些常用的配置。&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;官网下载： &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sublimetext.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后就是安装&lt;code&gt;package control&lt;/code&gt;: &lt;a href=&quot;https://packagecontrol.io/installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://packagecontrol.io/installation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>cmder使用</title>
    <link href="https://sampwood.github.io/2018/10/24/cmder%E4%BD%BF%E7%94%A8/"/>
    <id>https://sampwood.github.io/2018/10/24/cmder使用/</id>
    <published>2018-10-24T12:45:03.000Z</published>
    <updated>2019-03-06T05:51:53.733Z</updated>
    
    <content type="html"><![CDATA[<p>cmder是一个超棒的windows命令窗口。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址： <a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p><p>一般都只用下载mini版本就可以了，因为git都会自己下载 = =</p><a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为下载的mini版本，所以要使用bash的话就得自己配置git bash的路径</p><p>打开设置(win+alt+p)，在<code>StartUp</code>下面的<code>Tasks</code>中，点击右边<code>Predefined tasks</code>列表新建一个task<br>或者直接修改其中的<code>{bash::bash}</code>，在右侧最下面的文本框中填入git bash的路径。</p><p>例如： <code>cmd /c &quot;&quot;C:\Program Files\Git\bin\bash&quot; --login -i&quot;</code></p><p>同时，修改<code>{bash::bash as Admin}</code>: <code>*cmd /c &quot;&quot;C:\Program Files\Git\bin\bash&quot; --login -i&quot;</code></p><p>有此可见，<code>*</code>表示是否由管理员运行</p><p><strong>在<code>StartUp</code>中可以设置默认启动的task：在<code>Specified named task</code>选择想要的task</strong></p><p>当然，配置好之后记得点击保存</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmder是一个超棒的windows命令窗口。&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;下载地址： &lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmder.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般都只用下载mini版本就可以了，因为git都会自己下载 = =&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>在vps上搭建一个git仓库并实现代码提交之后自动部署到nginx上</title>
    <link href="https://sampwood.github.io/2018/10/17/vps-git-repo-ngxin-git-hook/"/>
    <id>https://sampwood.github.io/2018/10/17/vps-git-repo-ngxin-git-hook/</id>
    <published>2018-10-17T08:27:19.000Z</published>
    <updated>2019-03-06T05:51:53.740Z</updated>
    
    <content type="html"><![CDATA[<p>现在一般自己玩的项目都会托管在github上，然后使用github提供的git仓库地址来维护自己的代码。<br>例如<code>git@ github.com:Sampwood/sampwood.github.io.git</code>。</p><p>某一天，忽然想要开发一个私人的项目玩，感觉放在github上就不太好， 毕竟一些私人的东西不好放上去。<br>于是决定在自己的vps上搭建一个git仓库来维护自己的代码。</p><a id="more"></a><h3 id="vps上搭建git仓库"><a href="#vps上搭建git仓库" class="headerlink" title="vps上搭建git仓库"></a>vps上搭建git仓库</h3><p>对比github代码仓库ssh地址<code>git@ github.com:Sampwood/sampwood.github.io.git</code><br>和ssh登陆vps的命令<code>ssh root@**.**.**.**</code>。<br>我们可以这么理解代码仓库使用的ssh地址，就是git用户下Sampwood文件夹下的sampwood.github.io.git文件夹下的git仓库。</p><p>所以我们需要在vps上的操作就是安装git，创建git用户，以及新建git项目。</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>对于Ubuntu，只要两步：</p><p><code>$ add-apt-repository ppa:git-core/ppa</code>, <code>$ apt update; apt install git</code></p><p>具体其他的可参考官网：<a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">Download for Linux and Unix</a></p><h4 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h4><p>新建git用户并添加到sudo组： <code>$ adduser git --ingroup sudo</code></p><h5 id="使用ssh密钥"><a href="#使用ssh密钥" class="headerlink" title="使用ssh密钥"></a>使用ssh密钥</h5><p>使用git bash来生成ssh key：<br><code>$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p><p><em>PS: 为避免每次输入ssh key的密码，可以使用<code>ssh-agent</code>来管理ssh key。</em></p><p>然后上传key到vps：<br><code>ssh-copy-id git@**.**.**.**</code></p><h4 id="新建git项目"><a href="#新建git项目" class="headerlink" title="新建git项目"></a>新建git项目</h4><p>作为git仓库，一般只建一个bare仓库，因为不会直接在这里进行代码修改。<br>bare仓库不会包含实际项目源文件的拷贝，只有.git目录下的文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~ </span><br><span class="line">$ mkdir blog.git &amp;&amp; <span class="built_in">cd</span> blog.git</span><br><span class="line">$ git init --bare</span><br></pre></td></tr></table></figure></p><p>到这里，我们在vps上搭建git仓库的操作已经结束。<br>我们可以使用<code>git clone git@**.**.**.**:blog.git</code>来克隆代码了。</p><h3 id="git-hook响应push自动部署代码"><a href="#git-hook响应push自动部署代码" class="headerlink" title="git hook响应push自动部署代码"></a>git hook响应push自动部署代码</h3><p>blog.git是速度比较快的bare仓库，并不是可直接使用的目录，<br>所以需要制作一个POST Hooks将这个仓库clone到临时文件夹，再拷贝到实际www目录。</p><p>对应<code>git push</code>的hook钩子是<code>post-receive</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/blog.git/hooks</span><br><span class="line">$ touch post-receive</span><br><span class="line">$ vi post-receive</span><br></pre></td></tr></table></figure><p>使用下面的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define path</span></span><br><span class="line">GIT_REPO=/home/git/blog.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/blog</span><br><span class="line">PUBLIC_WWW=/var/www/blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean tmp directory</span></span><br><span class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># do some work</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">npm i</span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean public directory</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/dist/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show done info</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"githook: <span class="variable">$(date)</span>: Done"</span></span><br></pre></td></tr></table></figure></p><p>更改脚本权限和/var/www/blog权限<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x post-receive</span><br><span class="line">$ sudo chmod 775 -R /var/www/blog</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：这个脚本是针对前端项目的，而且其实更好的做法是通知持续集成（continous integration）的服务器。</p><p>另外这里贴一个更好的<code>post-receive</code>脚本的写法：<br><a href="https://gist.github.com/thomasfr/9691385" target="_blank" rel="noopener">How-to setup a simple git push deployment</a></p><p><strong>注意</strong>：如果碰到<code>Permission denied</code>，请修改文件拥有者： <code>sudo chown git file</code></p><h3 id="vps上搭建nginx"><a href="#vps上搭建nginx" class="headerlink" title="vps上搭建nginx"></a>vps上搭建nginx</h3><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>Ubuntu默认的源中就有Nginx，所以安装是比较简单的。<br>首先，更新apt源，以便软件是最新的，然后就可以安装nginx:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure></p><h4 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h4><p>开始测试Nginx前，我们需要配置防火墙，以便允许外界访问nginx服务。Nginx在安装的时候使用ufw注册自己作为一个服务，这样对nginx的访问就会变得很容易。</p><p>显示所有ufw应用的配置：<code>sudo ufw app list</code></p><p>我们可以得到一个配置的输出列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Available applications:</span><br><span class="line">  Nginx Full</span><br><span class="line">  Nginx HTTP</span><br><span class="line">  Nginx HTTPS</span><br><span class="line">  OpenSSH</span><br></pre></td></tr></table></figure></p><p>我们可以看到，有三个Nginx的配置：</p><ul><li><strong>Nginx Full</strong>: 这个配置打开 80端口和443端口</li><li><strong>Nginx HTTP</strong>: 这个配置只打开80 (普通, 未加密通信)</li><li><strong>Nginx HTTPS</strong>: 这个配置只打开 443 (TLS/SSL 加密通信 )</li></ul><p>一般来说我们应该配置最严的限制，因为本文我们还没有配置SSL，所以我们只打开80端口。</p><p>我们执行：<code>sudo ufw allow &#39;Nginx HTTP&#39;</code></p><p>验证修改状态:</p><p>我们可以看到HTTP是被打开的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">Nginx HTTP                 ALLOW       Anywhere                  </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)             </span><br><span class="line">Nginx HTTP (v6)            ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure></p><h4 id="检查web-server"><a href="#检查web-server" class="headerlink" title="检查web server"></a>检查web server</h4><p>安装完成后，Ubuntu 16.04 会自动启动 Nginx. 我们可以使用systemd 检查运行状态:<br><code>systemctl status nginx</code></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/nginx.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2018-10-15 04:23:21 UTC; 2 days ago</span><br><span class="line">     Docs: man:nginx(8)</span><br><span class="line">  Process: 9064 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 9061 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/ Main PID: 9068 (nginx)</span><br><span class="line">    Tasks: 2</span><br><span class="line">   Memory: 3.5M</span><br><span class="line">      CPU: 150ms</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─ 9068 nginx: master process /usr/sbin/nginx -g daemon on; master_process on</span><br><span class="line">           └─27117 nginx: worker process</span><br></pre></td></tr></table></figure></p><p>服务已经正常启动，当然最好的确认方法是通过访问web页面的方式。</p><h4 id="管理-Nginx-进程"><a href="#管理-Nginx-进程" class="headerlink" title="管理 Nginx 进程"></a>管理 Nginx 进程</h4><p>现在我们已经有nginx在运行了，我们可以再试一些管理命令：</p><ul><li>停止nginx: <code>sudo systemctl stop nginx</code></li><li>启动nginx: <code>sudo systemctl restart nginx</code></li><li>修改配置文件后，平滑加载配置命令(不会断开用户访问）：<code>sudo systemctl reload nginx</code></li><li>默认，nginx是随着系统启动的时候自动运行。如果你不想开机启动，那么你可以禁止nginx开机启动： <code>sudo systemctl disable nginx</code></li><li>重新配置nginx开机自动启动: <code>sudo systemctl enable nginx</code></li></ul><h4 id="Nginx的文件和目录"><a href="#Nginx的文件和目录" class="headerlink" title="Nginx的文件和目录"></a>Nginx的文件和目录</h4><p>现在我们已经管理nginx了，接下来可以熟悉一下nginx的目录结构和一些重要的文件：</p><p><strong>网站文件位置</strong></p><ul><li>/var/www/html: 网站文件存放的地方, 默认只有我们上面看到nginx页面，可以通过改变nginx配置文件的方式来修改这个位置。</li></ul><p><strong>服务器配置</strong></p><ul><li>/etc/nginx: nginx配置文件目录。所有的nginx配置文件都在这里。</li><li>/etc/nginx/nginx.conf: Nginx的主配置文件. 可以修改他来改变nginx的全局配置。</li><li>/etc/nginx/sites-available/: 这个目录存储每一个网站的”server blocks”。nginx通常不会使用这些配置，除非它们陪连接到  sites-enabled 目录 (see below)。一般所有的server block 配置都在这个目录中设置，然后软连接到别的目录 。</li><li>/etc/nginx/sites-enabled/: 这个目录存储生效的 “server blocks” 配置. 通常,这个配置都是链接到 sites-available目录中的配置文件</li><li>/etc/nginx/snippets: 这个目录主要可以包含在其它nginx配置文件中的配置片段。重复的配置都可以重构为配置片段。</li></ul><p><strong>日志文件</strong></p><ul><li>/var/log/nginx/access.log: 每一个访问请求都会记录在这个文件中，除非你做了其它设置。</li><li>/var/log/nginx/error.log: 任何Nginx的错误信息都会记录到这个文件中。</li></ul><h4 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h4><p>直接修改<code>/etc/nginx/sites-available</code>下的<code>default</code>文件，<br>或者新建一个<code>blog</code>文件并注释掉<code>default</code>中的内容。</p><p>写入nginx配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line"></span><br><span class="line">        server_name blog.sampwood.top; // 根据域名转发到不同端口</span><br><span class="line"></span><br><span class="line">        root /var/www/blog;</span><br><span class="line">        index index.html;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /var/www/blog;</span><br><span class="line">                try_files $uri $uri/ @router;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">                root html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location @router &#123;</span><br><span class="line">                rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        server_name _; // 默认nginx的访问页面</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是新建了一个<code>blog</code>文件，那在<code>/etc/nginx/sites-enabled</code>的文件夹下新建一个软连接：<br><code>ln  -s  /etc/nginx/sites-enabled/blog  /etc/nginx/sites-available/blog</code></p><p>然后就可以用<code>nginx -s reload</code>重新启动<code>nginx</code>了。</p><blockquote><p>到这里，差不多我们的工作就做完了。<br>现在，每次我们push代码之后，服务器会自动部署代码，我们也能访问nginx服务器看到新的改动。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://noahgao.net/2015/git-deploy-vps/" target="_blank" rel="noopener">使用Git在VPS上部署代码</a></li><li><a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">Download for Linux and Unix</a></li><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">Connecting to GitHub with SSH</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">自定义 Git - Git 钩子</a></li><li><a href="https://gist.github.com/thomasfr/9691385" target="_blank" rel="noopener">How-to setup a simple git push deployment</a></li><li><a href="http://www.nginx.cn/4723.html" target="_blank" rel="noopener">如何在ubuntu 16.04 上安装Nginx</a></li><li><a href="https://www.jianshu.com/p/93ac21161ac6" target="_blank" rel="noopener">nginx 基本入门(至今为止见过最好的 nginx 入门文章，没有之一。)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在一般自己玩的项目都会托管在github上，然后使用github提供的git仓库地址来维护自己的代码。&lt;br&gt;例如&lt;code&gt;git@ github.com:Sampwood/sampwood.github.io.git&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;某一天，忽然想要开发一个私人的项目玩，感觉放在github上就不太好， 毕竟一些私人的东西不好放上去。&lt;br&gt;于是决定在自己的vps上搭建一个git仓库来维护自己的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linux" scheme="https://sampwood.github.io/categories/coding/linux/"/>
    
    
      <category term="linux" scheme="https://sampwood.github.io/tags/linux/"/>
    
      <category term="git" scheme="https://sampwood.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>web缓存</title>
    <link href="https://sampwood.github.io/2018/06/18/web%E7%BC%93%E5%AD%98/"/>
    <id>https://sampwood.github.io/2018/06/18/web缓存/</id>
    <published>2018-06-18T07:48:36.000Z</published>
    <updated>2019-03-06T05:51:53.741Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><p>在这里整理一些web缓存的方法。</p><h3 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h3><p><img src="/images/classify.png" alt="缓存分类"></p><a id="more"></a><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从<strong>新鲜度</strong>和<strong>校验值</strong><br>两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。</p><p>对应的来说就是header中的4个参数：<code>Cache-Control</code>, <code>Expires</code>, <code>Last-Modified</code>, <code>ETag</code>。</p><h4 id="本地缓存阶段"><a href="#本地缓存阶段" class="headerlink" title="本地缓存阶段"></a>本地缓存阶段</h4><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control:"></a><code>Cache-Control</code>:</h5><ul><li>max-age: （单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</li><li>s-maxage: 单位为s）同max-age，只用于共享缓存（比如CDN缓存）。</li><li>public: 指定响应会被缓存，并且在多用户间共享。表示缓存的版本可以被代理服务器或者其他中间服务器识别。</li><li>private: 响应只作为私有的缓存（见下图），不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。</li><li>no-cache: 指定不缓存响应，表明资源不进行缓存</li><li>no-store: 绝对禁止缓存</li><li>must-revalidate: ?</li></ul><h5 id="Expires：指定缓存到期GMT的绝对时间-缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。"><a href="#Expires：指定缓存到期GMT的绝对时间-缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。" class="headerlink" title="Expires：指定缓存到期GMT的绝对时间; 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。"></a><code>Expires</code>：指定缓存到期GMT的绝对时间; 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</h5><p>如果设了<code>max-age</code>，<code>max-age</code>就会覆盖<code>expires</code>。如果<code>expires</code>到期需要重新请求。</p><h4 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h4><h5 id="Last-Modified和if-modified-since"><a href="#Last-Modified和if-modified-since" class="headerlink" title="Last-Modified和if-modified-since"></a><code>Last-Modified</code>和<code>if-modified-since</code></h5><p>这是一对报文头，属于http 1.0。</p><p>last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。</p><h5 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a><code>Etag</code>和<code>If-None-Match</code></h5><p>这是一对报文，属于http 1.1。</p><p>根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改。</p><p>Etag 主要为了解决 Last-Modified 无法解决的一些问题：</p><p>1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>3、某些服务器不能精确的得到文件的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 </p><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><h4 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h4><p>CDN缓存，也叫网关缓存、反向代理缓存。浏览器先向CDN网关发起WEB请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。</p><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。</p><p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求（back to the source request），从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><h3 id="HTML5缓存"><a href="#HTML5缓存" class="headerlink" title="HTML5缓存"></a>HTML5缓存</h3><h4 id="application-cache离线缓存"><a href="#application-cache离线缓存" class="headerlink" title="application cache离线缓存"></a>application cache离线缓存</h4><p>离线缓存有如下优势：</p><ul><li>用户可离线访问你的应用，这对于无法随时保持联网状态的移动终端用户来说尤其重要</li><li>用户访问本地的缓存文件，通常意味着更快的访问速度</li><li>仅仅加载被修改过的资源，避免同一资源对服务器多次的请求，大大降低了对服务器的访问压力</li></ul><p>实现方法是在<code>html</code>标签中配置指定的<code>manifest</code>文件(<code>&lt;html manifest=&quot;demo.manifest&quot;&gt;</code>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># wanz app v1</span><br><span class="line"></span><br><span class="line"># 指明缓存入口</span><br><span class="line">CACHE:</span><br><span class="line">index.html</span><br><span class="line">style.css</span><br><span class="line">images/logo.png</span><br><span class="line">scripts/main.js</span><br><span class="line"></span><br><span class="line"># 以下资源必须在线访问</span><br><span class="line">NETWORK:</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line"># 如果index.php无法访问则用404.html代替</span><br><span class="line">FALLBACK:</span><br><span class="line">/index.php /404.html</span><br></pre></td></tr></table></figure></p><p>在文件中配合js使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.applicationCache.status === <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">    <span class="built_in">window</span>.applicationCache.swapCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个过程中有几个问题需要注意：</p><ul><li>如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。</li><li>对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。</li><li>浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。</li><li>在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用<code>window.applicationCache.swapCache()</code>方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。</li><li>配置manifest的<strong>index.html文件也会被缓存</strong>。</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p><code>cookie</code>非常小，它的大小限制为4KB左右。主要用途有保存登录信息，做身份认证。<br>cookie是不可跨域的，他会根据域名来区分是向哪个服务器发送数据。</p><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>sessionStorage和localStorage是html5提供的两种本地存储方式，只会存在本地，大小要比cookie大</p><p>sessionStorage是用户从打开回话窗到关闭会话窗这一段时间有效，关闭之后存的数据就会被删除。</p><p><strong>刷新页面数据依旧存在，但不同会话窗口之间不同享</strong></p><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>严格说来localStorage更像是cookie一类的本地数据存储。但在标准缓存之外，开发人员可以用浏览器的一些功能来实现自定义的客户端“缓存”。</p><p>与sessionStroage主要的区别是存储时间和作用域。</p><p>LocalStorage是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；<br>LocalStorage是以页面域名划分的，如果有多个等价域名之间的LocalStorage不互通，则会造成缓存多份浪费。</p><p>LocalStorage在PC上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用localStorage的速度比不上304。<br>并且不能缓存css文件。而移动端由于网速慢，使用localStorage要快于304。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="noopener">浅谈Web缓存</a></li><li><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">缓存策略</a></li><li><a href="http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1" target="_blank" rel="noopener">前端工程精粹（一）：静态资源版本更新与缓存</a></li><li><a href="http://jerryzou.com/posts/cookie-and-web-storage/" target="_blank" rel="noopener">详说 Cookie, LocalStorage 与 SessionStorage</a></li><li><a href="https://segmentfault.com/a/1190000012478396" target="_blank" rel="noopener">前端存储浅谈——cookie、sessionStorage、localStorage</a></li><li><a href="https://segmentfault.com/a/1190000010400892" target="_blank" rel="noopener">cookie、sessionStorage、localStorage 详解及应用场景</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。&lt;/p&gt;
&lt;p&gt;在这里整理一些web缓存的方法。&lt;/p&gt;
&lt;h3 id=&quot;缓存分类&quot;&gt;&lt;a href=&quot;#缓存分类&quot; class=&quot;headerlink&quot; title=&quot;缓存分类&quot;&gt;&lt;/a&gt;缓存分类&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/classify.png&quot; alt=&quot;缓存分类&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="缓存" scheme="https://sampwood.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>threejs study</title>
    <link href="https://sampwood.github.io/2018/06/03/threejs-study/"/>
    <id>https://sampwood.github.io/2018/06/03/threejs-study/</id>
    <published>2018-06-03T09:20:56.000Z</published>
    <updated>2019-03-06T05:51:53.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>threejs是一个用来创建三维图形应用的js库。<br>说到三维图形应用，就不得不提一句webGL。在百度百科中是这么描述webGL的：<br><code>WebGL（全写Web Graphics Library）是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。</code><br>也就是说：<code>WebGL可以看做是将OpenGL ES（OpenGL for Embedded Systems，OpenGL嵌入式版本，针对手机、游戏机等设备相对较轻量级的版本）移植到了网页平台</code>。</p><p>Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。<br>除了WebGL之外，Three.js还提供了基于Canvas、SVG标签的渲染器。</p><a id="more"></a><p>下面就开始具体说下threejs的代码实现。</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello, world!"></a>hello, world!</h4><p>一个典型的Three.js程序至少要包括渲染器（Renderer）、场景（Scene）、照相机（Camera），以及你在场景中创建的物体。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染器（Renderer）</span></span><br><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123;</span><br><span class="line">    canvas: <span class="built_in">document</span>.getElementById(<span class="string">'mainCanvas'</span>) <span class="comment">// 先要在html中定义id为mainCanvas的&lt;canvas&gt;&lt;/canvas&gt;元素</span></span><br><span class="line">&#125;);</span><br><span class="line">renderer.setClearColor(<span class="number">0x000000</span>); <span class="comment">// 设置背景色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景（scene）：相当于大的容器</span></span><br><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene(); <span class="comment">// 一般说，场景里没有很复杂的操作，在程序最开始的时候进行实例化，然后将物体添加到场景中即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 照相机（Camera）</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, <span class="number">4</span> / <span class="number">3</span>, <span class="number">1</span>, <span class="number">1000</span>); <span class="comment">// 这个是透视相机。当然还有其他相机</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物体</span></span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(<span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="comment">// CubeGeometry是长方体</span></span><br><span class="line">    <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="comment">// material是材质，用于物体的颜色，贴图之类的</span></span><br><span class="line">        color: <span class="number">0xff0000</span></span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一步：渲染</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure></p><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>WebGL和Three.js使用的坐标系是右手坐标系。</p><p><img src="/images/threejs-coordinate.png" alt="坐标系"></p><p>针对投影方式的不同，照相机又分为正交投影照相机（Orthographic Camera）与透视投影照相机（Perspective Camera）。</p><h4 id="正交投影照相机"><a href="#正交投影照相机" class="headerlink" title="正交投影照相机"></a>正交投影照相机</h4><p>正交投影照相机（Orthographic Camera）设置起来较为直观，它的构造函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p><p><img src="/images/orthographic-camera.png" alt="正交相机"></p><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。(ps: 其实意思是如果比例不一致的时候，会用相机的内容去填充canvas的大小，所以相机的内容的长宽会被相应的拉伸)</p><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p><p>使用实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1.5</span>, <span class="number">-1.5</span>, <span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 创建实例</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 设置位置</span></span><br><span class="line">camera.lookAt(<span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 默认照相机是沿z轴负方向观察的，可以通过lookAt函数指定它看着原点方向。</span></span><br></pre></td></tr></table></figure></p><h4 id="透视投影照相机"><a href="#透视投影照相机" class="headerlink" title="透视投影照相机"></a>透视投影照相机</h4><p>透视投影照相机（Perspective Camera）的构造函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.PerspectiveCamera(fov, aspect, near, far)</span><br></pre></td></tr></table></figure><p><img src="/images/perspective-camera.png" alt="透视相机"></p><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。<br>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。<br>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p><p>使用实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, <span class="number">400</span> / <span class="number">300</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h3 id="物体（网格）"><a href="#物体（网格）" class="headerlink" title="物体（网格）"></a>物体（网格）</h3><p>在创建物体时，需要传入两个参数，一个是几何形状（Geometry），另一个是材质（Material）。</p><h4 id="几何形状"><a href="#几何形状" class="headerlink" title="几何形状"></a>几何形状</h4><p>几何形状（Geometry）最主要的功能是储存了一个物体的顶点信息。WebGL需要程序员指定每个顶点的位置，而在Three.js中，可以通过指定一些特征来创建几何形状，例如使用半径创建一个球体，从而省去程序员一个个指定顶点的工作量。</p><h5 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h5><p>在长方体中，width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然这一形状的名字叫立方体（CubeGeometry），但它其实是长方体，也就是长宽高可以设置为不同的值。其构造函数是：</span></span><br><span class="line"><span class="keyword">new</span> THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平面，这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面</span></span><br><span class="line"><span class="keyword">new</span> THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体</span></span><br><span class="line"><span class="keyword">new</span> THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">new</span> THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆柱体</span></span><br><span class="line"><span class="keyword">new</span> THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正四面体、正八面体、正二十面体</span></span><br><span class="line"><span class="keyword">new</span> THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line"><span class="keyword">new</span> THREE.OctahedronGeometry(radius, detail)</span><br><span class="line"><span class="keyword">new</span> THREE.IcosahedronGeometry(radius, detail)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆环面</span></span><br><span class="line"><span class="keyword">new</span> THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆环结</span></span><br><span class="line"><span class="keyword">new</span> THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure><h5 id="文字形状"><a href="#文字形状" class="headerlink" title="文字形状"></a>文字形状</h5><p>文字形状（TextGeometry）可以用来创建三维的文字形状。</p><p>创建文字形状的流程和之前介绍的基本几何形状是类似的，其构造函数是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.TextGeometry(text, parameters)</span><br></pre></td></tr></table></figure></p><p>其中，text是文字字符串，parameters是以下参数组成的对象：</p><ul><li>size：字号大小，一般为大写字母的高度</li><li>height：文字的厚度</li><li>curveSegments：弧线分段数，使得文字的曲线更加光滑</li><li>font：字体，默认是’helvetiker’，需对应引用的字体文件</li><li>weight：值为’normal’或’bold’，表示是否加粗</li><li>style：值为’normal’或’italics’，表示是否斜体</li><li>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</li><li>bevelThickness：倒角厚度</li><li>bevelSize：倒角宽度</li></ul><p>使用文字形状需要下载和引用额外的字体库。</p><p>这里，我们以<code>helvetiker</code>字体为例。我们在<code>Three.js GitHub master/examples/fonts</code>目录下，下载<code>helvetiker_regular.typeface.json</code>文件放在你的目录下，然后用以下方法加载：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FontLoader();</span><br><span class="line">loader.load(<span class="string">'../lib/helvetiker_regular.typeface.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">font</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(<span class="keyword">new</span> THREE.TextGeometry(<span class="string">'Hello'</span>, &#123;</span><br><span class="line">        font: font,</span><br><span class="line">        size: <span class="number">1</span>,</span><br><span class="line">        height: <span class="number">1</span></span><br><span class="line">    &#125;), material);</span><br><span class="line">    scene.add(mesh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render</span></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="自定义形状"><a href="#自定义形状" class="headerlink" title="自定义形状"></a>自定义形状</h5><p>对于Three.js没有提供的形状，可以提供自定义形状来创建。<br>自定义形状使用的是Geometry类，它是其他如CubeGeometry、SphereGeometry等几何形状的父类，其构造函数是：<code>new THREE.Geometry()</code></p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p>材质（Material）是独立于物体顶点信息之外的与渲染效果相关的属性。通过设置材质可以改变物体的颜色、纹理贴图、光照模式等。</p><h5 id="基本材质"><a href="#基本材质" class="headerlink" title="基本材质"></a>基本材质</h5><p>使用基本材质（BasicMaterial）的物体，渲染后物体的颜色始终为该材质的颜色，而不会由于光照产生明暗、阴影效果。如果没有指定材质的颜色，则颜色是随机的。其构造函数是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.MeshBasicMaterial(opt)</span><br></pre></td></tr></table></figure></p><p>其中，opt可以缺省，或者为包含各属性的值。opt可以是以下的几个较为常用的属性：</p><ul><li>visible：是否可见，默认为true</li><li>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</li><li>wireframe：是否渲染线而非面，默认为false</li><li>color：十六进制RGB颜色，如红色表示为0xff0000</li><li>map：使用纹理贴图</li></ul><h5 id="Lambert材质"><a href="#Lambert材质" class="headerlink" title="Lambert材质"></a>Lambert材质</h5><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。<br>其构造函数是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.MeshLambertMaterial(opt)</span><br></pre></td></tr></table></figure></p><p>opt可以是以下的属性：</p><ul><li>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</li><li>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</li><li>emissive是材质的自发光颜色，可以用来表现光源的颜色</li></ul><h5 id="Phong材质"><a href="#Phong材质" class="headerlink" title="Phong材质"></a>Phong材质</h5><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。<br>其构造函数是：<code>new THREE.MeshPhongMaterial(opt)</code></p><p>同样地，可以指定emissive和ambient值，还可以使用specular值指定镜面反射系数作说明。</p><h5 id="法向材质"><a href="#法向材质" class="headerlink" title="法向材质"></a>法向材质</h5><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。<br>法向材质的设定很简单，甚至不用设置任何参数：<code>new THREE.MeshNormalMaterial()</code></p><h5 id="材质的纹理贴图"><a href="#材质的纹理贴图" class="headerlink" title="材质的纹理贴图"></a>材质的纹理贴图</h5><p>材质的纹理贴图的意思就是说，threejs可以支持我们自己倒入图片作为纹理贴图，添加到相应的材质中。</p><p>实例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个加载器</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载一个资源</span></span><br><span class="line">loader.load(</span><br><span class="line">    <span class="comment">// 资源链接</span></span><br><span class="line">    <span class="string">'src/img/chess.png'</span>,</span><br><span class="line">    <span class="comment">// 资源加载完成后的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"> texture </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something with the texture</span></span><br><span class="line">        <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123;</span><br><span class="line">            map: texture</span><br><span class="line">         &#125; );</span><br><span class="line">        <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(plane, material);</span><br><span class="line">        scene.add(cube);</span><br><span class="line">        renderer.render(scene, camera); <span class="comment">// 导入纹理之前，已经完成了一次渲染，所以导入之后还需要重新渲染</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 资源加载过程中的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"> xhr </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( (xhr.loaded / xhr.total * <span class="number">100</span>) + <span class="string">'% loaded'</span> );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 资源下载出错时的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"> xhr </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'An error happened'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h4><p>网格是最常用的一种物体。网格是由顶点、边、面等组成的物体；其他物体包括线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等。<br>网格的构造函数是：<code>Mesh(geometry, material)</code></p><h5 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h5><p>除了在构造函数中指定材质，在网格被创建后，也能对材质进行修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个网格</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: <span class="number">0xffff00</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改网格颜色</span></span><br><span class="line">mesh.material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: <span class="number">0xff0000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 位置</span></span><br><span class="line">mesh.position.z = <span class="number">1</span>;</span><br><span class="line">mesh.position.set(<span class="number">1.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>);</span><br><span class="line">mesh.position = <span class="keyword">new</span> THREE.Vector3(<span class="number">1.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 缩放,具体方法与上例相同，分别表示沿x、y、z三轴缩放或旋转。</span></span><br><span class="line">mesh.scale =</span><br><span class="line"><span class="comment">// 旋转,具体方法与上例相同，分别表示沿x、y、z三轴缩放或旋转。</span></span><br><span class="line">mesh.rotation =</span><br></pre></td></tr></table></figure></p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>正如动画片的原理一样，动画的本质是利用了人眼的视觉暂留特性，快速地变换画面，从而产生物体在运动的假象。而对于Three.js程序而言，动画的实现也是通过在每秒中多次重绘画面实现的。<br>所以可以使用<code>setInterval</code>来实现，也可以用：<code>requestAnimationFrame</code>。</p><h4 id="使用stat-js观察FPS"><a href="#使用stat-js观察FPS" class="headerlink" title="使用stat.js观察FPS"></a>使用stat.js观察FPS</h4><p>stat.js是Three.js的作者Mr. Doob的另一个有用的JavaScript库。stat.js就能提供实时监测动画效果。实例图如下：</p><p><img src="/images/statjs.png" alt="statjs"></p><p>实例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对其初始化并将其添加至屏幕右上角</span></span><br><span class="line"><span class="keyword">var</span> stat = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stat = <span class="keyword">new</span> Stats();</span><br><span class="line">    stat.domElement.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">    stat.domElement.style.right = <span class="string">'0px'</span>;</span><br><span class="line">    stat.domElement.style.top = <span class="string">'0px'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(stat.domElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Three.js init ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在动画重绘函数draw中调用stat.begin();与stat.end();分别表示一帧的开始与结束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stat.begin();</span><br><span class="line"></span><br><span class="line">    mesh.rotation.y = (mesh.rotation.y + <span class="number">0.01</span>) % (<span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line"></span><br><span class="line">    stat.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="外部模型"><a href="#外部模型" class="headerlink" title="外部模型"></a>外部模型</h3><p>Three.js允许用户导入由3ds Max等工具制作的三维模型，并添加到场景中。</p><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders可以找到。" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders可以找到。</a></p><p><code>*.obj</code>是最常用的模型格式，导入<code>*.obj</code>文件需要OBJLoader.js；导入带<code>*.mtl</code>材质的<code>*.obj</code>文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p><p>目前，支持的模型格式有：</p><ul><li>*.obj</li><li><em>.obj, </em>.mtl</li><li>*.dae</li><li>*.ctm</li><li>*.ply</li><li>*.stl</li><li>*.wrl</li><li>*.vtk</li></ul><p>无材质模型导入实例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例子需要OBJLoader.js</span></span><br><span class="line"><span class="comment">// 创建loader实例</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.OBJLoader();</span><br><span class="line">loader.load(<span class="string">'../lib/port.obj'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    mesh = obj; <span class="comment">//储存到全局变量中</span></span><br><span class="line">    scene.add(obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>有材质模型导入实例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例子需要MTLLoader.js与OBJMTLLoader.js</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.OBJMTLLoader();</span><br><span class="line">loader.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = event.content;</span><br><span class="line">    mesh = obj;</span><br><span class="line">    scene.add(obj);</span><br><span class="line">&#125;);</span><br><span class="line">loader.load(<span class="string">'../lib/port.obj'</span>, <span class="string">'../lib/port.mtl'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="光与影"><a href="#光与影" class="headerlink" title="光与影"></a>光与影</h3><p>图像渲染的丰富效果很大程度上也要归功于光与影的利用。</p><h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。其构造函数是：<code>new THREE.AmbientLight(hex)</code>。</p><p>关于环境光有个好玩的现象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当我们将环境光设置为红色，场景内同样放置绿色0x00ff00和白色0xffffff的长方体。</span><br><span class="line">渲染的结果是这两个长方体都被渲染成了环境光的红色！！！</span><br><span class="line"></span><br><span class="line">这一结果可能有些出乎你的意料。其实，环境光并不在乎物体材质的color属性，而是ambient属性。ambient属性的默认值是0xffffff。</span><br><span class="line">ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</span><br></pre></td></tr></table></figure></p><p>当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p><h4 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h4><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。<br>点光源的构造函数是：<code>new THREE.PointLight(hex, intensity, distance)</code></p><h4 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h4><p>对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。<br>平行光的构造函数是：<code>new THREE.DirectionalLight(hex, intensity)</code></p><h4 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h4><p>聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p><p>其构造函数为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure></p><p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p><p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure></p><p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(<span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0x00ff00</span>&#125;));</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffff00</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="built_in">Math</span>.PI / <span class="number">6</span>, <span class="number">25</span>);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure></p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>在Three.js中，能形成阴影的光源只有<code>THREE.DirectionalLight</code>与<code>THREE.SpotLight</code>；而相对地，能表现阴影效果的材质只有<code>THREE.LambertMaterial</code>与<code>THREE.PhongMaterial</code>。因而在设置光源和材质的时候，一定要注意这一点。</p><p>实例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们需要在初始化时，告诉渲染器渲染阴影：</span></span><br><span class="line">renderer.shadowMapEnabled = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 然后，对于光源以及所有要产生阴影的物体调用：</span></span><br><span class="line">xxx.castShadow = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 对于接收阴影的物体调用：</span></span><br><span class="line">xxx.receiveShadow = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p><p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p><p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p><p><img src="/images/shadow.jpeg" alt="shadow"></p><p>如果想要修改阴影的深浅，可以通过设置shadowDarkness，该值的范围是0到1，越小越浅。</p><p>另外，这里实现阴影效果的方法是Shadow Mapping，即阴影是作为渲染前计算好的贴图贴上去的，因而会受到贴图像素大小的限制。所以可以通过设置shadowMapWidth与shadowMapHeight值控制贴图的大小，来改变阴影的精确度。</p><p>而如果想实现软阴影的效果，可以通过renderer.shadowMapSoft = true;方便地实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ituring.com.cn/book/1272" target="_blank" rel="noopener">Three.js入门指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;threejs是一个用来创建三维图形应用的js库。&lt;br&gt;说到三维图形应用，就不得不提一句webGL。在百度百科中是这么描述webGL的：&lt;br&gt;&lt;code&gt;WebGL（全写Web Graphics Library）是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。&lt;/code&gt;&lt;br&gt;也就是说：&lt;code&gt;WebGL可以看做是将OpenGL ES（OpenGL for Embedded Systems，OpenGL嵌入式版本，针对手机、游戏机等设备相对较轻量级的版本）移植到了网页平台&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。&lt;br&gt;除了WebGL之外，Three.js还提供了基于Canvas、SVG标签的渲染器。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="WebGL" scheme="https://sampwood.github.io/tags/WebGL/"/>
    
      <category term="threejs" scheme="https://sampwood.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>parenting</title>
    <link href="https://sampwood.github.io/2018/05/27/parenting/"/>
    <id>https://sampwood.github.io/2018/05/27/parenting/</id>
    <published>2018-05-27T13:38:09.000Z</published>
    <updated>2019-03-06T05:51:53.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ol><li>护理喂养疾病：《美国儿科协会育儿百科0~5岁》。<strong>建议阅读时间</strong>：根据月龄读，可以作为随时放在案边查询的工具书。</li><li>规律作息和睡眠问题:《实用程序育儿法》。<strong>建议阅读时间</strong>：宝宝1个月之前读完，可以对今后规划宝宝作息有个全面的安排。而且小月龄宝宝更加容易培养好习惯。当然如果你错过了，现在补看也可以。</li><li>心理认知发展: 《你的1岁孩子》。<strong>建议阅读时间</strong>：宝宝6个月以后，或者当你觉得应付宝宝吃睡等这些基础问题已经游刃有余时。</li><li>如何与孩子互动：《游戏力》。</li><li>《崔玉涛：宝贝健康公开课》</li><li>《张思莱育儿微访谈》</li><li>《给孩子一口漂亮的牙齿》</li><li>《冀连梅谈：中国人应该这样用药》</li><li>《郑玉巧育儿经》胎儿卷、婴儿卷、幼儿卷</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.zhihu.com/question/20853110" target="_blank" rel="noopener">有哪些值得推荐的育儿类图书？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;书籍&quot;&gt;&lt;a href=&quot;#书籍&quot; class=&quot;headerlink&quot; title=&quot;书籍&quot;&gt;&lt;/a&gt;书籍&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;护理喂养疾病：《美国儿科协会育儿百科0~5岁》。&lt;strong&gt;建议阅读时间&lt;/strong&gt;：根据月龄读，可以作为随时放在案边
      
    
    </summary>
    
      <category term="随笔" scheme="https://sampwood.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的浮点数计算</title>
    <link href="https://sampwood.github.io/2018/05/18/float-calculate/"/>
    <id>https://sampwood.github.io/2018/05/18/float-calculate/</id>
    <published>2018-05-18T12:27:09.000Z</published>
    <updated>2019-03-21T04:26:46.856Z</updated>
    
    <content type="html"><![CDATA[<p>由于<code>舍入误差</code>的存在，浮点数的计算会不是很精确。例如<code>1.11 * 100 =&gt; 111.00000000000001</code>。</p><p>下面是一段简单处理的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//按照有效数字位数进行四舍五入，默认6位有效数字</span><br><span class="line">Math.signFigures = function(num, rank = 6) &#123;</span><br><span class="line">    if(!num) return(0);</span><br><span class="line">    let sign = num / Math.abs(num);</span><br><span class="line">    let number = num * sign;</span><br><span class="line">    let temp = rank - 1 - Math.floor(Math.log10(number));</span><br><span class="line">    let ans;</span><br><span class="line">    if (temp &gt; 0) &#123;</span><br><span class="line">        ans = parseFloat(number.toFixed(temp));</span><br><span class="line">    &#125; else if (temp &lt; 0) &#123;</span><br><span class="line">        temp = Math.pow(10, temp);</span><br><span class="line">        ans = Math.round(number / temp) * temp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ans = Math.round(number);</span><br><span class="line">    &#125;</span><br><span class="line">    return (ans * sign);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Math.signFigures(123.242545, 1) 会出问题！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/q/1010000005697295" target="_blank" rel="noopener">为什么js里面有些数字*100结果会不准确?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于&lt;code&gt;舍入误差&lt;/code&gt;的存在，浮点数的计算会不是很精确。例如&lt;code&gt;1.11 * 100 =&amp;gt; 111.00000000000001&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是一段简单处理的代码：&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="浮点数" scheme="https://sampwood.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>jsts-polygon-study</title>
    <link href="https://sampwood.github.io/2018/05/14/jsts-polygon-study/"/>
    <id>https://sampwood.github.io/2018/05/14/jsts-polygon-study/</id>
    <published>2018-05-14T01:57:56.000Z</published>
    <updated>2019-03-06T05:51:53.737Z</updated>
    
    <content type="html"><![CDATA[<p>在这里主要说一些在图形应用中多边形相关的判断和操作。<br>例如求点映射到线上的坐标，计算点到线的距离，以及点是否在多边形内，点到多边形的距离。<br>最后介绍一个第三方库：jsts。</p><a id="more"></a><h3 id="一些多边形的判断和操作"><a href="#一些多边形的判断和操作" class="headerlink" title="一些多边形的判断和操作"></a>一些多边形的判断和操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点到线的映射坐标</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; p 点</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; a 线段起始点</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; b 线段终止点</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; 线上的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFocusPoint</span>(<span class="params">p, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> point = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 如果a.x === b.x 说明是条竖着的线</span></span><br><span class="line">  <span class="keyword">if</span> (a.x - b.x === <span class="number">0</span>) &#123;</span><br><span class="line">    p.x = a.x;</span><br><span class="line">    p.y = p.y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> k = (a.y - b.y) / (a.x - b.x);</span><br><span class="line">    <span class="keyword">let</span> l = a.y - k * a.x;</span><br><span class="line">    <span class="keyword">let</span> m = p.x + k * p.y;</span><br><span class="line"></span><br><span class="line">    point.x = (m - k * l) / (k * k + <span class="number">1</span>);</span><br><span class="line">    point.y = k * point.x + l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算点到线段的距离</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; p 点</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; a 线段起始点</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; b 线段终止点</span></span><br><span class="line"><span class="comment"> * @return &#123;Number&#125;   距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToSegmentDist</span>(<span class="params">p, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> AB = [b.x - a.x, b.y - a.y]</span><br><span class="line">  <span class="keyword">let</span> AP = [p.x - a.x, p.y - a.y]</span><br><span class="line">  <span class="keyword">let</span> AB_AP = AB.x * AP.x + AB.y * AP.y</span><br><span class="line">  <span class="keyword">let</span> distAB2 = AB.x * AB.x + AB.y * AB.y</span><br><span class="line">  <span class="keyword">let</span> D = [a.x, a.y]</span><br><span class="line">  <span class="keyword">if</span> (distAB2 != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = AB_AP / distAB2</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      D = [b.x, b.y]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      D = [a.x + AB.x * t, a.y + AB.y * t]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      D = [a.x, a.y]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> AD = [p.x - a.x, p.y - a.y]</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(AD.x * AD.x + AD.y * AD.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断点是否在多边形内部，一般用射线法</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; p 点</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; polygon 多边形坐标</span></span><br><span class="line"><span class="comment"> * @return &#123;Number&#125; 1: 在内部，0: 在外部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointInPolygon</span>(<span class="params">p, polygon</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 统计p点右边交点的个数</span></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = polygon[i]</span><br><span class="line">    <span class="keyword">var</span> b = polygon[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> ((a.y &gt; p.y !== b.y &gt; p.y) &amp;&amp;</span><br><span class="line">      (p.x &lt; (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count % <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断点到多边形的最近距离</span></span><br><span class="line"><span class="comment"> * @param  &#123;&#123;x: Number, y: Number&#125;&#125; p 点</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; polygon 多边形坐标</span></span><br><span class="line"><span class="comment"> * @return &#123;Number&#125; 最短距离；点在多边形内部，距离为正；在多边形外部，距离为负；在边上，距离为零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToPolygonDist</span>(<span class="params">p, polygon</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 统计p点右边交点的个数</span></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> minDist = <span class="literal">Infinity</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = polygon[i]</span><br><span class="line">    <span class="keyword">var</span> b = polygon[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> ((a.y &gt; p.y !== b.y &gt; p.y) &amp;&amp;</span><br><span class="line">      (p.x &lt; (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) count++;</span><br><span class="line">    minDist = <span class="built_in">Math</span>.min(minDist, pointToSegmentDist(p, a, b))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count % <span class="number">2</span> === <span class="number">0</span>) minDist = -minDist</span><br><span class="line">  <span class="keyword">return</span> minDist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维坐标围绕某个点旋转特定角度</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; pointList 二维坐标集合</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; theta     弧度</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125; point     旋转点</span></span><br><span class="line"><span class="comment"> * @return &#123;Array&#125;            结果集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotationByPoint</span>(<span class="params">pointList, theta, point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;x, y&#125; = point;</span><br><span class="line">  <span class="keyword">let</span> sinTheta = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">  <span class="keyword">let</span> cosTheta = <span class="built_in">Math</span>.cos(theta);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> m00 = cosTheta;</span><br><span class="line">  <span class="keyword">let</span> m01 = -sinTheta;</span><br><span class="line">  <span class="keyword">let</span> m02 = x - x * cosTheta + y * sinTheta;</span><br><span class="line">  <span class="keyword">let</span> m10 = sinTheta;</span><br><span class="line">  <span class="keyword">let</span> m11 = cosTheta;</span><br><span class="line">  <span class="keyword">let</span> m12 = y - x * sinTheta - y * cosTheta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pointList.map(<span class="function"><span class="params">src</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dest = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> xp = m00 * src.x + m01 * src.y + m02;</span><br><span class="line">    <span class="keyword">let</span> yp = m10 * src.x + m11 * src.y + m12;</span><br><span class="line">    dest.x = xp;</span><br><span class="line">    dest.y = yp;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jsts"><a href="#jsts" class="headerlink" title="jsts"></a>jsts</h3><p>JSTS是一个Javascript符合OGC规范的简单要素空间位置关系判定和函数的类库，JSTS也是总所周知的java类库JST的一个接口。</p><p>下面是一些jsts的操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a_coor = <span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> b_coor = <span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> c_coor = <span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> d_coor = <span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="keyword">new</span> jsts.geom.GeometryFactory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ring = factory.createLinearRing([a_coor, b_coor, c_coor, d_coor, a_coor]);</span><br><span class="line"><span class="keyword">let</span> line = factory.createLineString([<span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">0.5</span>, <span class="number">0</span>), <span class="keyword">new</span> jsts.geom.Coordinate(<span class="number">1</span>, <span class="number">0</span>)]);</span><br><span class="line"><span class="keyword">let</span> polygon = factory.createPolygon([a_coor, b_coor, c_coor, d_coor, a_coor]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0.5</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> mouse_coor = <span class="keyword">new</span> jsts.geom.Coordinate(x, y);</span><br><span class="line"><span class="keyword">let</span> mouse_point = factory.createPoint(mouse_coor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> distance = <span class="keyword">new</span> jsts.operation.distance.DistanceOp(mouse_point, ring);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'nearest points'</span>, distance.nearestPoints());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'distance'</span>, distance.distance())</span><br><span class="line"><span class="built_in">console</span>.log(ring.contains(mouse_point))</span><br></pre></td></tr></table></figure></p><h4 id="jsts的一些API"><a href="#jsts的一些API" class="headerlink" title="jsts的一些API"></a>jsts的一些API</h4><ul><li>两个多边形是否相交：polygon1.intersects(polygon2) =&gt; true/false</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://bjornharrtell.github.io/jsts/" target="_blank" rel="noopener">JSTS demonstration</a></li><li><a href="http://locationtech.github.io/jts/javadoc/" target="_blank" rel="noopener">JTS javadoc</a></li><li><a href="https://github.com/bjornharrtell/jsts/tree/gh-pages" target="_blank" rel="noopener">JSTS gh-pages</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这里主要说一些在图形应用中多边形相关的判断和操作。&lt;br&gt;例如求点映射到线上的坐标，计算点到线的距离，以及点是否在多边形内，点到多边形的距离。&lt;br&gt;最后介绍一个第三方库：jsts。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="js" scheme="https://sampwood.github.io/categories/coding/js/"/>
    
    
      <category term="polygon" scheme="https://sampwood.github.io/tags/polygon/"/>
    
  </entry>
  
  <entry>
    <title>css之float&amp;BFC</title>
    <link href="https://sampwood.github.io/2018/03/28/css-float-BFC/"/>
    <id>https://sampwood.github.io/2018/03/28/css-float-BFC/</id>
    <published>2018-03-28T14:07:29.000Z</published>
    <updated>2019-03-06T05:51:53.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>虽然说浮动和绝对定位都是脱离文档流的布局且父元素获取不到元素高度，但浮动还是和绝对定位有一定的区别的。<br>绝对定位是<strong>绝对</strong>地脱离文档流，不会对正常文档流产生任何影响。<br>而浮动则会在文档流中占据一定的位置。这个从文字环绕float图片就可以看出来。<br>当然，浮动最开始的意图就是为了能让文字环绕图片。</p><a id="more"></a><p>说到浮动，就不得不说下<code>inline boxes</code>和<code>line boxes</code>的概念。<br>视觉格式化模型(Visual formatting model)下，文档中每个元素在页面布局中都会产生一个对应的盒子（box）。<br>块级元素对应<code>block box</code>，行级元素对应<code>inline boxes</code>，整行的元素会对应一个<code>line boxes</code>。<br>对于块级元素下面直接写的文字，称之为<code>匿名inline boxes</code>。</p><p>正常情况下<code>inline boxes</code>的基线是对齐的，所以只有一行文字会和图片处在同一行内。<code>line box</code>的高度由行内最高的<code>inline boxes</code>决定。<br>但是增加<code>float</code>属性之后，破坏了元素的<code>inline boxes</code>，使其脱离了其原来所在的<code>line box</code>链，跟随自身的方位属性，靠边排列。（有点类似于<code>display: inline-block</code>）<br>但浮动元素依旧在文档流中，同处于文档流中的文字实体不会与浮动元素重叠，就出现了文字环绕显示。</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(block formatting context)，块格式化上下文，是Web页面中盒模型布局的CSS渲染模式。它的定位体系属于常规文档流。</p><p>在css的渲染原理中，BFC主要有下面几种生成途径：</p><ol><li>根节点（html结点）</li><li><code>float</code>不为<code>none</code>的元素</li><li><code>overflow</code>不为visible的元素</li><li><code>display</code>为<code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>, <code>flex</code>, 或者 <code>inline-flex</code>中的其中一个。</li><li><code>position</code>为<code>absolute</code>的元素</li></ol><p>BFC主要有下面几个特点：</p><ol><li>BFC内部的排版不会和外面的元素相互影响</li><li>当BFC内部又产生BFC的时候，外面的BFC不会包含内部BFC的子元素</li><li>BFC会计算浮动元素的高宽</li><li>在BFC中，每个盒子的左外边框都紧挨着包含快的左边框（从右到左的格式，则紧挨着右边框），除非盒子内部创建了一个新的BFC</li><li>同一个BFC中存在外边距折叠，即<code>margin-top</code>和<code>margin-bottom</code>的重合；不同的BFC则不存在外边距折叠</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/59b73d5bf265da064618731d" target="_blank" rel="noopener">学习 BFC (Block Formatting Context)</a></li><li><a href="https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html" target="_blank" rel="noopener">理解CSS中BFC</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/" target="_blank" rel="noopener">CSS float浮动的深入研究、详解及拓展(一)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;float&quot;&gt;&lt;a href=&quot;#float&quot; class=&quot;headerlink&quot; title=&quot;float&quot;&gt;&lt;/a&gt;float&lt;/h3&gt;&lt;p&gt;虽然说浮动和绝对定位都是脱离文档流的布局且父元素获取不到元素高度，但浮动还是和绝对定位有一定的区别的。&lt;br&gt;绝对定位是&lt;strong&gt;绝对&lt;/strong&gt;地脱离文档流，不会对正常文档流产生任何影响。&lt;br&gt;而浮动则会在文档流中占据一定的位置。这个从文字环绕float图片就可以看出来。&lt;br&gt;当然，浮动最开始的意图就是为了能让文字环绕图片。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="css" scheme="https://sampwood.github.io/categories/coding/css/"/>
    
    
      <category term="css" scheme="https://sampwood.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>setup environment in ubuntu</title>
    <link href="https://sampwood.github.io/2018/03/17/setup-environment-in-ubuntu/"/>
    <id>https://sampwood.github.io/2018/03/17/setup-environment-in-ubuntu/</id>
    <published>2018-03-17T04:42:38.000Z</published>
    <updated>2019-03-06T05:51:53.738Z</updated>
    
    <content type="html"><![CDATA[<ol><li>添加用户：<code>useradd –d /home/sam -m sam</code></li><li>添加密码：<code>passwd sam</code></li><li>给用户添加组(添加sudo功能)：<code>usermod -aG sudo,adm sam</code></li><li>修改服务端使用的shell：<code>sudo vim /etc/passwd</code>，编辑/etc/passwd文件，给新建的用户指定shell解释器，添加<strong>/bin/bash</strong>：<code>sam:x:1000:1000::/home/sam:/bin/bash</code></li><li>更新apt源：<code>sudo apt-get update</code></li><li><a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">安装git</a>：<code># add-apt-repository ppa:git-core/ppa</code> <code># apt update; apt install git</code></li><li><a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">安装node</a>：<code>curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</code> <code>sudo apt-get install -y nodejs</code></li><li>安装Mongodb：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;添加用户：&lt;code&gt;useradd –d /home/sam -m sam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加密码：&lt;code&gt;passwd sam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;给用户添加组(添加sudo功能)：&lt;code&gt;usermod -aG sud
      
    
    </summary>
    
      <category term="coding" scheme="https://sampwood.github.io/categories/coding/"/>
    
      <category term="linux" scheme="https://sampwood.github.io/categories/coding/linux/"/>
    
    
      <category term="environment" scheme="https://sampwood.github.io/tags/environment/"/>
    
  </entry>
  
</feed>
